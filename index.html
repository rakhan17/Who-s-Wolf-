<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Who's Wolf</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üê∫</text></svg>">
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0b1220;
      --text: #e6eef8;
      --muted: #9ca3af;
      --card: rgba(255, 255, 255, 0.02);
      --border: rgba(148, 163, 184, 0.08);
      --card-gradient-start: rgba(255, 255, 255, 0.02);
      --card-gradient-end: rgba(255, 255, 255, 0.01);
    }
    .light-theme {
      --bg: #f1f5f9;
      --text: #1e293b;
      --muted: #64748b;
      --card: #ffffff;
      --border: #e2e8f0;
      --card-gradient-start: #ffffff;
      --card-gradient-end: #f8fafc;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:'Poppins',system-ui,Segoe UI,Roboto; overflow: hidden; transition: background-color 0.3s, color 0.3s;}
    
    body.shake { animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both; }
    @keyframes shake { 10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-4px, 0, 0); } 40%, 60% { transform: translate3d(4px, 0, 0); } }

    .screen{display:flex; align-items:center; justify-content:center; position:absolute; inset:0; padding:16px; box-sizing:border-box; opacity:0; transition:opacity 0.4s ease-in-out; pointer-events:none;}
    .screen.active{ opacity:1; pointer-events:auto; }

    .card{background:linear-gradient(180deg, var(--card-gradient-start), var(--card-gradient-end));border-radius:14px;padding:24px;border:1px solid var(--border);box-shadow:0 8px 24px rgba(2,6,23,0.1); transition: background-color 0.3s, border-color 0.3s;}
    .muted{color:var(--muted)}
    .input-wrapper{position:relative;width:100%;}
    .input-icon{position:absolute;left:12px;top:50%;transform:translateY(-50%);color:#94a3b8}
    input.input-field{width:100%;padding:12px 14px;border-radius:12px;background:transparent;border:1px solid var(--border);color:var(--text);outline:none}
    input.input-field.has-icon { padding-left: 44px; }
    .btn{display:inline-flex;align-items:center;justify-content:center;gap:.6rem;padding:.7rem 1rem;border-radius:12px;font-weight:700;cursor:pointer;border:0; transition: all 0.2s ease;}
    .btn:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .btn-primary{background:linear-gradient(90deg,#7c3aed,#4f46e5);color:white}
    .btn-secondary{background:#1f2937;color:#cbd5e1}
    .light-theme .btn-secondary { background: #e2e8f0; color: #334155; }
    .btn-danger{background:linear-gradient(90deg,#ef4444,#b91c1c);color:white}
    .btn-green{background:linear-gradient(90deg,#10b981,#06b6d4);color:white}
    .spinner{width:20px;height:20px;border-radius:50%;border:2px solid rgba(125,125,125,0.2);border-top-color:var(--text);animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
    
    .modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center;z-index:50; opacity: 0; transition: opacity 0.3s ease; pointer-events:none;}
    .modal{min-width:280px;max-width:420px; opacity: 0; transform: scale(0.95); transition: all 0.3s ease;}
    .modal-backdrop.active { opacity: 1; pointer-events:auto; }
    .modal-backdrop.active .modal { opacity: 1; transform: scale(1); }
    #event-modal .modal { max-width: 520px; }

    #notification-toast {position: fixed; top: 20px; left: 50%; transform: translateX(-50%); padding: 12px 24px; border-radius: 10px; color: white; font-weight: 600; box-shadow: 0 4px 15px rgba(0,0,0,0.3); z-index: 100; opacity: 0; transition: opacity 0.3s, top 0.3s; pointer-events: none;}
    #notification-toast.show { opacity: 1; top: 30px; }
    
    .screen * { box-sizing:border-box }
    .hidden { display: none !important; }

    .shimmer-tag { font-size: 10px; font-weight: bold; padding: 2px 8px; border-radius: 5px; color: white; background: linear-gradient(270deg, #ff2d2d, #ff7b7b, #ff2d2d); background-size: 200% 200%; animation: shimmer 2s ease infinite; }
    @keyframes shimmer { 0%{background-position:200% 0} 100%{background-position:-200% 0} }

    .toggle-label { display: flex; align-items: center; justify-content: space-between; cursor: pointer; width: 100%; }
    .toggle-label input { display: none; }
    .toggle-switch { position: relative; display: inline-block; width: 40px; height: 22px; background-color: rgba(125,125,125,0.2); border-radius: 22px; transition: background-color 0.2s; }
    .toggle-switch::after { content: ''; position: absolute; width: 18px; height: 18px; border-radius: 50%; background-color: white; top: 2px; left: 2px; transition: transform 0.2s; }
    .toggle-label input:checked + .toggle-switch { background-color: #4f46e5; }
    .toggle-label input:checked + .toggle-switch::after { transform: translateX(18px); }

    .targeted-vote { border: 2px solid #7c3aed !important; animation: pulse-vote 1.5s infinite; }
    @keyframes pulse-vote { 0% { box-shadow: 0 0 0 0 rgba(124, 58, 237, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(124, 58, 237, 0); } 100% { box-shadow: 0 0 0 0 rgba(124, 58, 237, 0); } }
    .targeted-kill { border: 2px solid #ef4444 !important; animation: pulse-red 1.5s infinite; }
    @keyframes pulse-red { 0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); } 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); } }
    .targeted-protect { border: 2px solid #22c55e !important; animation: pulse-green 1.5s infinite; }
    @keyframes pulse-green { 0% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(34, 197, 94, 0); } 100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0); } }

    #phase-transition-overlay { position: fixed; inset: 0; z-index: 999; display: flex; flex-direction:column; align-items: center; justify-content: center; font-size: 8rem; color: white; pointer-events: none; opacity: 0; transition: opacity 0.5s ease-in-out; }
    #phase-transition-overlay.day { background: radial-gradient(circle, rgba(251,191,36,0.8) 0%, rgba(251,191,36,0) 70%); }
    #phase-transition-overlay.night { background: radial-gradient(circle, rgba(79,70,229,0.6) 0%, rgba(79,70,229,0) 70%); }
    #phase-transition-overlay.visible { opacity: 1; }
    #phase-title { font-size: 2rem; font-weight: bold; margin-top: -2rem; text-shadow: 0 2px 10px rgba(0,0,0,0.5); }
    .lag-indicator { font-size: 10px; font-weight: bold; padding: 2px 8px; border-radius: 5px; color: white; background: #f97316; margin-left: 8px; }
  </style>
</head>
<body>
  <div id="phase-transition-overlay">
    <div id="phase-icon"></div>
    <div id="phase-title"></div>
  </div>

  <div id="notification-toast"></div>

  <div id="loading-overlay" class="screen active" style="z-index:40">
    <div style="text-align:center">
      <div style="font-size:56px">üê∫</div>
      <h1 style="font-size:26px;margin:6px 0;">Who's Wolf?</h1>
      <div class="spinner" style="width:32px; height:32px; border-width:3px; margin: 20px auto 12px auto;"></div>
      <div class="muted">Connecting...</div>
    </div>
  </div>

  <div id="nickname-screen" class="screen" style="z-index:10">
    <div class="card" style="width:100%;max-width:420px;text-align:center">
      <div style="font-size:56px">üê∫</div>
      <h1 style="font-size:26px;margin:6px 0">Welcome!</h1>
      <p class="muted">Enter your nickname to play</p>
      <div style="margin-top:16px;">
        <div class="input-wrapper" style="margin-bottom:12px"><span class="input-icon">üôç</span><input id="nickname-input" class="input-field has-icon" placeholder="Your Nickname" maxlength="25"></div>
        <button id="btn-enter-lobby" class="btn btn-primary" style="width:100%">Enter Lobby</button>
      </div>
    </div>
  </div>

  <div id="lobby-screen" class="screen" style="z-index:15">
    <div class="card" style="width:100%;max-width:900px">
      <div style="display:flex;justify-content:space-between;align-items:center; padding-bottom: 16px; border-bottom: 1px solid var(--border);">
        <div style="display:flex; align-items:center; gap:12px;">
            <div style="font-size:32px">üê∫</div>
            <h2 style="margin:0; font-size:22px;">Who's Wolf?</h2>
        </div>
        <div style="display:flex; align-items:center; gap:16px;">
          <button id="theme-toggle-btn" class="btn btn-secondary p-2">üåì</button>
          <div id="welcome-container" style="text-align:right;">
            <div class="flex items-center gap-2">
              <h2 id="welcome-text" style="margin:0; font-size:18px;">Welcome</h2>
              <button id="btn-edit-name" class="text-sm">‚úèÔ∏è</button>
            </div>
            <p class="muted" id="welcome-sub" style="margin:0; font-size:12px;">Ready to hunt?</p>
          </div>
          <button id="btn-how-to-play" class="btn btn-secondary">How to Play</button>
        </div>
      </div>

      <div id="pre-room-view" style="margin-top:24px; display:flex; flex-direction:column; align-items:center; gap: 24px;">
        <div style="text-align:center; width:100%; max-width:320px;">
          <h3 style="margin-top:0; margin-bottom:12px; font-weight:600;">Create a New Room</h3>
          <button id="btn-create-room" class="btn btn-primary" style="width:100%;">Create Room</button>
        </div>
        <div style="display:flex; align-items:center; gap:12px; width:100%; max-width: 320px; color: var(--muted);">
          <hr style="flex:1; border:0; border-top: 1px solid var(--border);"><span class="text-sm">OR</span><hr style="flex:1; border:0; border-top: 1px solid var(--border);">
        </div>
        <div style="text-align:center; width:100%; max-width:320px;">
          <h3 style="margin-top:0; margin-bottom:12px; font-weight:600;">Join an Existing Room</h3>
          <div style="display:flex;gap:8px;">
            <input id="join-code" class="input-field" placeholder="ROOM CODE" style="flex:1; text-transform:uppercase;"/>
            <button id="btn-join" class="btn btn-green">Join</button>
          </div>
        </div>
      </div>

      <div id="in-room-view" class="hidden" style="margin-top:12px;">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;">
            <h3 style="margin:0">Room Code: <span id="room-code-display" style="color:#7c3aed; font-weight:700; cursor:pointer;"></span></h3>
            <button id="btn-leave" class="btn btn-secondary">Leave Room</button>
        </div>
        <div style="display:flex;gap:16px">
          <div style="flex:1">
            <h4 style="margin:0 0 8px 0">Players (<span id="player-count">0</span>)</h4>
            <div id="player-list" style="min-height:220px;max-height:220px;overflow:auto;border-radius:10px;padding:8px;background:rgba(125,125,125,0.05)"></div>
          </div>
          <div id="room-settings-panel" style="width:360px">
            <div class="card" style="padding:16px">
              <h3 style="margin:0 0 12px 0">Room Settings</h3>
              <div class="space-y-3">
                <div>
                  <label class="muted text-sm">Werewolves</label>
                  <input id="setting-wolves" type="number" min="1" value="1" class="input-field setting-input w-full mt-1"/>
                </div>
                <div class="grid grid-cols-2 gap-x-4 gap-y-2">
                  <label class="toggle-label muted">Seer <input id="setting-seer" type="checkbox" checked class="setting-input"><span class="toggle-switch"></span></label>
                  <label class="toggle-label muted">Doctor <input id="setting-doctor" type="checkbox" checked class="setting-input"><span class="toggle-switch"></span></label>
                  <label class="toggle-label muted">Hunter <input id="setting-hunter" type="checkbox" class="setting-input"><span class="toggle-switch"></span></label>
                </div>
                <div class="grid grid-cols-2 gap-4 pt-2">
                  <div>
                    <label class="muted text-sm">Day (s)</label>
                    <input id="setting-day" type="number" value="60" class="input-field setting-input w-full mt-1"/>
                  </div>
                  <div>
                    <label class="muted text-sm">Night (s)</label>
                    <input id="setting-night" type="number" value="45" class="input-field setting-input w-full mt-1"/>
                  </div>
                </div>
              </div>
            </div>
             <button id="btn-start" class="btn btn-primary hidden" style="width:100%; margin-top:12px;">Start Game</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="game-screen" class="screen" style="z-index:20; display:flex; flex-direction:column; gap:16px; padding:16px;">
    <div class="card" style="width:100%; padding:12px 24px; display:flex; justify-content:space-between; align-items:center;">
      <div>
        <h2 id="game-phase-title" style="margin:0; font-size:22px;">Night 1</h2>
        <p id="game-phase-subtitle" class="muted" style="margin:0; font-size:14px;">The village is asleep...</p>
      </div>
      <div class="flex items-center gap-4">
        <button id="skip-vote-btn" class="btn btn-secondary hidden">Skip Vote</button>
        <div style="text-align:center;">
          <div id="game-timer" style="font-size:28px; font-weight:700;">00:45</div>
          <div class="muted" style="font-size:12px;">TIME REMAINING</div>
        </div>
      </div>
    </div>

    <div style="width:100%; flex:1; display:flex; gap:16px; overflow:hidden;">
      <div style="display:flex; flex-direction:column; gap:16px; width:280px;">
        <div class="card" style="padding:16px; flex:1; display:flex; flex-direction:column;">
          <h3 style="margin:0 0 8px 0;">Players</h3>
          <div id="game-player-list" style="overflow-y:auto; flex:1;"></div>
        </div>
        <div id="developer-panel" class="card hidden" style="padding:16px;">
          <h4 style="margin:0 0 8px 0; color:#ff5555;">Developer Tools</h4>
          <p class="muted text-xs">Use with caution!</p>
          <button id="dev-end-game" class="btn btn-secondary w-full text-xs">End Game</button>
        </div>
      </div>

      <div id="game-main-content" class="card p-4 flex-1 overflow-y-auto grid gap-4 grid-cols-2 md:grid-cols-3 lg:grid-cols-4 content-start">
      </div>

      <div class="card" style="padding:16px; width:320px; display:flex; flex-direction:column;">
        <h3 style="margin:0 0 8px 0;">Global Chat</h3>
        <div id="chat-messages" style="flex:1; overflow-y:auto; margin-bottom:8px; font-size:14px;"></div>
        <div style="display:flex; gap:8px;">
          <input id="chat-input" class="input-field" style="flex:1;" placeholder="Type a message..." disabled/>
          <button id="chat-send" class="btn btn-primary" disabled>Send</button>
        </div>
      </div>
    </div>
  </div>

  <div id="role-reveal-overlay" class="screen" style="z-index: 25; background: rgba(11, 18, 32, 0.9); text-align: center; color: white;">
      <div class="card" style="text-align:center;">
        <div id="role-reveal-emoji" style="font-size:80px; margin-bottom:12px;"></div>
        <h1 id="role-reveal-name" style="font-size:28px; margin:0;"></h1>
        <p id="role-reveal-description" class="muted" style="margin-top:8px;"></p>
        <div id="role-reveal-allies" class="mt-4"></div>
      </div>
  </div>
  
  <div id="seer-result-modal" class="modal-backdrop">
    <div class="modal card" style="text-align:center;">
        <h1 id="seer-result-title" style="font-size:28px; margin:0;">Seer's Vision</h1>
        <p id="seer-result-body" class="muted" style="margin-top:16px;"></p>
        <button onclick="showModal('seer-result-modal', false)" class="btn btn-primary w-full mt-4">Close</button>
    </div>
  </div>

  <div id="event-modal" class="modal-backdrop">
    <div class="modal card" style="text-align:center;">
        <h1 id="event-title" style="font-size:28px; margin:0;"></h1>
        <div id="event-body" class="muted" style="margin-top:16px; text-align:left;"></div>
        <button id="btn-close-event" class="btn btn-primary w-full mt-4">Continue</button>
    </div>
  </div>

  <div id="rules-modal-backdrop" class="modal-backdrop">
    <div class="modal card">
        <h2 style="margin-top:0">How to Play Who's Wolf</h2>
        <p class="muted">The game is divided into two phases: Night and Day. The goal of the Villagers is to eliminate all Werewolves. The goal of the Werewolves is to outnumber the Villagers.</p>
        <h3 style="margin-bottom:8px;">Roles</h3>
        <div style="display:grid; grid-template-columns: 1fr 1fr; gap:12px;">
            <div><strong>üê∫ Werewolf</strong><p class="muted" style="font-size:14px;">During the night, wake up with fellow werewolves to choose one player to eliminate.</p></div>
            <div><strong>üë± Villager</strong><p class="muted" style="font-size:14px;">During the day, discuss and vote to eliminate a player you suspect is a werewolf.</p></div>
            <div><strong>üëÅÔ∏è Seer</strong><p class="muted" style="font-size:14px;">During the night, you can choose one player to learn their true identity (Werewolf or not).</p></div>
            <div><strong>üßë‚Äç‚öïÔ∏è Doctor</strong><p class="muted" style="font-size:14px;">During the night, you can choose one player to protect from a werewolf attack for that night.</p></div>
            <div><strong>üëÆ Hunter</strong><p class="muted" style="font-size:14px;">You have one bullet. At night, you can choose to shoot a player you think is a werewolf.</p></div>
        </div>
        <div style="text-align:right; margin-top:20px;">
            <button id="btn-close-rules" class="btn btn-primary">Got it!</button>
        </div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js';
    import { getAuth, onAuthStateChanged, signInAnonymously, updateProfile } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js';
    import { getFirestore, doc, collection, setDoc, getDoc, runTransaction, onSnapshot, deleteField, updateDoc, deleteDoc, serverTimestamp, query, orderBy, addDoc, where, Timestamp } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js';

    const screens = document.querySelectorAll('.screen');
    function showScreen(id){ screens.forEach(s => s.classList.toggle('active', s.id === id)); }
    const loadingOverlay = document.getElementById('loading-overlay');
    function setLoading(on){ loadingOverlay.classList.toggle('active', on); }
    function showToast(msg, err=false){
      const t = document.getElementById('notification-toast');
      t.textContent = msg;
      t.style.background = err ? 'linear-gradient(90deg,#ef4444,#f97316)' : 'linear-gradient(90deg,#10b981,#06b6d4)';
      t.classList.add('show');
      setTimeout(()=> t.classList.remove('show'), 3000);
    }
    window.showModal = (id, show) => {
        document.getElementById(id)?.classList.toggle('active', show);
    }

    let auth, db;
    const firebaseConfig = {
      apiKey: "AIzaSyCsPjYivo2bQp-fsr5wcdBfTRIiAcSbJNo",
      authDomain: "who-s-wolf.firebaseapp.com",
      projectId: "who-s-wolf",
      storageBucket: "who-s-wolf.appspot.com",
      messagingSenderId: "981640498887",
      appId: "1:981640498887:web:92e582b23c6588d48a78e2",
    };

    function initializeFirebase() {
        try {
            const app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            handleAuthentication();
        } catch(e) {
            console.error("Firebase Init Error:", e);
            showToast('Failed to initialize application.', true);
        }
    }

    let currentUser = null;
    const DEV_PREFIX = "[slnana]";
    
    function getDisplayName(playerOrNickname) {
        let nickname = '';
        if (typeof playerOrNickname === 'string') {
            nickname = playerOrNickname;
        } else if (playerOrNickname && playerOrNickname.nickname) {
            nickname = playerOrNickname.nickname;
        }

        if (nickname.toLowerCase().startsWith(DEV_PREFIX)) {
            return nickname.substring(DEV_PREFIX.length).trim();
        }
        return nickname;
    }

    async function handleAuthentication() {
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                const isDev = user.displayName?.toLowerCase().startsWith(DEV_PREFIX) || false;
                currentUser = { 
                    uid: user.uid, 
                    displayName: user.displayName,
                    isDeveloper: isDev
                };
                if (user.displayName) {
                    updateWelcomeText(user.displayName);
                    showScreen('lobby-screen');
                } else {
                    showScreen('nickname-screen');
                }
                setLoading(false);
            } else {
                try { await signInAnonymously(auth); } catch (error) {
                    console.error("Anonymous Sign In Error:", error);
                    showToast('Failed to connect to server.', true);
                }
            }
        });
    }
    
    function updateWelcomeText(name) {
        const displayName = getDisplayName(name);
        const welcomeTextEl = document.getElementById('welcome-text');
        welcomeTextEl.textContent = displayName;
        if (name.toLowerCase().startsWith(DEV_PREFIX)) {
            const devTag = document.createElement('span');
            devTag.className = 'shimmer-tag ml-2';
            devTag.textContent = 'Developer';
            welcomeTextEl.appendChild(devTag);
        }
    }

    async function setNickname(nickname) {
        if (!nickname) { showToast('Nickname cannot be empty!', true); return false; }
        setLoading(true);
        try {
            await updateProfile(auth.currentUser, { displayName: nickname });
            currentUser.displayName = nickname;
            currentUser.isDeveloper = nickname.toLowerCase().startsWith(DEV_PREFIX);
            updateWelcomeText(nickname);
            showScreen('lobby-screen');
            return true;
        } catch (error) {
            console.error("Update Profile Error:", error);
            showToast('Failed to save nickname.', true);
            return false;
        } finally { setLoading(false); }
    }

    document.getElementById('btn-enter-lobby').addEventListener('click', () => {
        setNickname(document.getElementById('nickname-input').value.trim());
    });
    document.getElementById('btn-edit-name').addEventListener('click', () => {
        const newName = prompt("Enter new nickname:", currentUser.displayName);
        if (newName) setNickname(newName.trim());
    });

    let currentRoomId = null;
    let roomUnsub = null;
    let chatUnsub = null;
    let gameTimerInterval = null;
    let presenceInterval = null;
    let localGameState = {};
    let playerOrder = [];

    function setLobbyView(inRoom) {
        document.getElementById('pre-room-view').classList.toggle('hidden', inRoom);
        document.getElementById('in-room-view').classList.toggle('hidden', !inRoom);
    }
    
    function startPresenceUpdates() {
        if (presenceInterval) clearInterval(presenceInterval);
        presenceInterval = setInterval(async () => {
            if (currentRoomId && currentUser && db) {
                const roomRef = doc(db, 'rooms', currentRoomId);
                try { await updateDoc(roomRef, { [`players.${currentUser.uid}.lastSeen`]: serverTimestamp() }); } catch (e) { /* Fail silently */ }
            }
        }, 15000);
    }

    function stopPresenceUpdates() {
        if (presenceInterval) clearInterval(presenceInterval);
        presenceInterval = null;
    }

    async function createRoom(){
      setLoading(true);
      try {
        const code = Math.random().toString(36).substring(2,8).toUpperCase();
        const roomRef = doc(db, 'rooms', code);
        await setDoc(roomRef, { 
            hostId: currentUser.uid, 
            players: { [currentUser.uid]: { nickname: currentUser.displayName, isHost: true, isDeveloper: currentUser.isDeveloper, lastSeen: serverTimestamp() } }, 
            settings: getSettingsFromUI(), state: 'lobby', createdAt: serverTimestamp()
        });
        currentRoomId = code;
        try { window.history.replaceState({}, '', '?room=' + code); } catch (e) { console.warn("Could not update URL:", e); }
        subscribeToRoom(code);
        showToast('Room created: ' + code);
      } catch(e){
        console.error("Create Room Error:", e);
        showToast('Failed to create room.', true);
      } finally { setLoading(false); }
    }

    async function joinRoom(code){
      setLoading(true);
      try {
        const roomRef = doc(db, "rooms", code);
        await runTransaction(db, async (transaction) => {
            const roomDoc = await transaction.get(roomRef);
            if (!roomDoc.exists()) throw new Error("Room not found!");
            const roomData = roomDoc.data();
            if (roomData.state !== 'lobby') throw new Error("Game has already started!");
            transaction.update(roomRef, { [`players.${currentUser.uid}`]: { nickname: currentUser.displayName, isHost: false, isDeveloper: currentUser.isDeveloper, lastSeen: serverTimestamp() } });
        });
        currentRoomId = code;
        try { window.history.replaceState({}, '', '?room=' + code); } catch (e) { console.warn("Could not update URL:", e); }
        subscribeToRoom(code);
        showToast('Joined ' + code);
      } catch (error) {
          console.error("Join Room Error:", error);
          showToast(`Failed to join: ${error.message}`, true);
      } finally { setLoading(false); }
    }

    function subscribeToRoom(code){
      if(roomUnsub) roomUnsub();
      startPresenceUpdates();
      const roomRef = doc(db, 'rooms', code);
      roomUnsub = onSnapshot(roomRef, snap => {
        if(!snap.exists()){
          showToast('Room closed.', true);
          handleRoomClose();
          return;
        }
        const roomData = snap.data();
        const oldState = localGameState.state;
        localGameState = roomData;
        
        if (roomData.hostId === currentUser.uid && roomData.state !== 'lobby' && !roomData.processing) {
            hostGameLogic(roomData);
        }

        if (roomData.state === 'lobby' && oldState !== 'lobby' && oldState !== undefined) {
            showScreen('lobby-screen');
            renderLobbyView(roomData);
            return;
        }
        
        if (roomData.state !== 'lobby' && !roomData.players[currentUser.uid]) {
            showToast("You were kicked or the game ended.", true);
            handleRoomClose();
            return;
        }

        switch(roomData.state) {
            case 'lobby': showScreen('lobby-screen'); renderLobbyView(roomData); break;
            case 'role_reveal': renderRoleReveal(roomData); break;
            case 'night': case 'day': renderGamePhase(roomData, oldState); break;
            case 'announcement': renderAnnouncement(roomData); break;
            case 'game_over': renderGameOver(roomData); break;
        }
      }, err => {
        console.error("Room subscription error:", err);
        showToast('Connection to room lost.', true);
        handleRoomClose();
      });
      subscribeToChat(code);
    }
    
    function subscribeToChat(code) {
        if (chatUnsub) chatUnsub();
        const chatRef = collection(db, 'rooms', code, 'messages');
        const q = query(chatRef, orderBy('timestamp', 'asc'));
        chatUnsub = onSnapshot(q, (snapshot) => {
            const chatMessages = document.getElementById('chat-messages');
            chatMessages.innerHTML = '';
            snapshot.forEach(doc => {
                const msg = doc.data();
                const msgEl = document.createElement('div');
                const displayName = getDisplayName(msg);
                let nickHTML = `<strong>${displayName}</strong>`;
                if(msg.isDeveloper) nickHTML += ` <span class="shimmer-tag ml-2">Developer</span>`;
                msgEl.innerHTML = `<p class="mb-1">${nickHTML}: ${msg.text}</p>`;
                chatMessages.appendChild(msgEl);
            });
            chatMessages.scrollTop = chatMessages.scrollHeight;
        });
    }

    async function leaveRoom(){
      if(currentRoomId){
        const roomRef = doc(db, "rooms", currentRoomId);
        try {
            const roomDoc = await getDoc(roomRef);
            if (roomDoc.exists()) {
                const roomData = roomDoc.data();
                const isHost = roomData.hostId === currentUser.uid;
                if (isHost || Object.keys(roomData.players).length <= 1) {
                    await deleteDoc(roomRef);
                } else {
                    await updateDoc(roomRef, { [`players.${currentUser.uid}`]: deleteField() });
                }
            }
        } catch(e){ console.error('Leave Room Error:', e); }
      }
      handleRoomClose();
    }
    
    function handleRoomClose() {
        if(roomUnsub){ roomUnsub(); roomUnsub = null; }
        if(chatUnsub){ chatUnsub(); chatUnsub = null; }
        stopPresenceUpdates();
        currentRoomId = null;
        playerOrder = [];
        if(gameTimerInterval) clearInterval(gameTimerInterval);
        try { window.history.replaceState({}, '', location.pathname); } catch (e) { console.warn("Could not update URL:", e); }
        setLobbyView(false);
        showScreen('lobby-screen');
    }
    
    async function kickPlayer(playerIdToKick) {
        if (!currentRoomId) return;
        const roomRef = doc(db, "rooms", currentRoomId);
        try {
            await updateDoc(roomRef, { [`players.${playerIdToKick}`]: deleteField() });
            showToast("Player kicked successfully.");
        } catch (e) { console.error("Kick Player Error:", e); showToast("Failed to kick player.", true); }
    }

    function renderLobbyView(roomData){
      setLobbyView(true);
      const codeDisplay = document.getElementById('room-code-display');
      codeDisplay.textContent = currentRoomId || '----';
      codeDisplay.onclick = () => {
          navigator.clipboard.writeText(currentRoomId).then(() => showToast('Room code copied!'), () => showToast('Failed to copy code.', true));
      };

      const list = document.getElementById('player-list');
      list.innerHTML = '';
      const players = roomData.players || {};
      const playerIds = Object.keys(players);
      document.getElementById('player-count').textContent = playerIds.length;
      const isCurrentUserHost = roomData.hostId === currentUser.uid;

      playerIds.sort((a,b) => getDisplayName(players[a]).localeCompare(getDisplayName(players[b]))).forEach(pid => {
        const p = players[pid];
        const el = document.createElement('div');
        el.className = 'flex justify-between items-center p-2 rounded-lg mb-2';
        const displayName = getDisplayName(p);
        const isOnline = p.lastSeen && (Date.now() / 1000 - p.lastSeen.seconds < 30);
        let statusHTML = '';
        if (!isOnline) {
            statusHTML = `<span class="lag-indicator">Lag</span>`;
        }
        let nickHTML = `<strong>${displayName} ${p.isHost ? 'üëë' : ''}</strong>`;
        if(p.isDeveloper) nickHTML += ` <span class="shimmer-tag ml-2">Developer</span>`;
        const nameDiv = document.createElement('div');
        nameDiv.innerHTML = `<div>${nickHTML}</div><div>${statusHTML}</div>`;
        nameDiv.className = 'flex items-center';
        el.appendChild(nameDiv);

        if ((isCurrentUserHost || currentUser.isDeveloper) && pid !== currentUser.uid && !p.isHost) {
            const kickBtn = document.createElement('button');
            kickBtn.textContent = 'Kick';
            kickBtn.className = 'btn btn-danger text-xs px-2 py-1';
            kickBtn.onclick = () => { if(confirm(`Are you sure you want to kick ${displayName}?`)) kickPlayer(pid); };
            el.appendChild(kickBtn);
        }
        list.appendChild(el);
      });

      document.getElementById('room-settings-panel').style.display = isCurrentUserHost ? 'block' : 'none';
      document.getElementById('btn-start').classList.toggle('hidden', !isCurrentUserHost || playerIds.length < 3);
      updateSettingsUI(roomData.settings, !isCurrentUserHost);
    }
    
    function getSettingsFromUI() {
        return {
            numWerewolves: parseInt(document.getElementById('setting-wolves').value || 1),
            includeSeer: document.getElementById('setting-seer').checked,
            includeDoctor: document.getElementById('setting-doctor').checked,
            includeHunter: document.getElementById('setting-hunter').checked,
            dayDuration: parseInt(document.getElementById('setting-day').value || 60),
            nightDuration: parseInt(document.getElementById('setting-night').value || 45)
        };
    }
    function updateSettingsUI(settings, disableInputs) {
        if (!settings) return;
        document.getElementById('setting-wolves').value = settings.numWerewolves;
        document.getElementById('setting-seer').checked = settings.includeSeer;
        document.getElementById('setting-doctor').checked = settings.includeDoctor;
        document.getElementById('setting-hunter').checked = settings.includeHunter;
        document.getElementById('setting-day').value = settings.dayDuration;
        document.getElementById('setting-night').value = settings.nightDuration;
        document.querySelectorAll('.setting-input').forEach(input => input.disabled = disableInputs);
    }
    
    async function updateSettingsInDb() {
        if (!currentRoomId || !currentUser.uid) return;
        const roomRef = doc(db,'rooms', currentRoomId);
        try {
            const snap = await getDoc(roomRef);
            if (snap.exists() && snap.data().hostId === currentUser.uid) {
                await updateDoc(roomRef, { settings: getSettingsFromUI() });
            }
        } catch (e) { console.error("Update Settings Error:", e); showToast("Failed to save settings.", true); }
    }

    async function hostGameLogic(roomData) {
        const roomRef = doc(db, 'rooms', currentRoomId);
        const { state, players, phaseEndTime } = roomData;

        if ((state === 'night' || state === 'day') && phaseEndTime && Timestamp.now().seconds > phaseEndTime.seconds) {
            await updateDoc(roomRef, { processing: true });
            let nextStateData = {};
            
            if (state === 'night') {
                nextStateData = processNightActions(roomData);
            } else { // day
                nextStateData = processDayVotes(roomData);
            }
            
            const winState = checkWinCondition(nextStateData.players || players);
            if (winState) {
                await updateDoc(roomRef, { state: 'game_over', gameOver: winState, processing: false });
            } else {
                await updateDoc(roomRef, { ...nextStateData, processing: false });
            }
        }
    }
    
    function processNightActions(roomData) {
        let { players, turn, devActions = {} } = roomData;
        let events = [];
        const wolfVotes = {};
        let doctorSaveTarget = null;
        let hunterShotTarget = null;

        Object.entries(players).forEach(([pid, p]) => {
            if (p.isAlive && p.actionTarget) {
                if (p.role === 'werewolf') wolfVotes[p.actionTarget] = (wolfVotes[p.actionTarget] || 0) + 1;
                else if (p.role === 'doctor') doctorSaveTarget = p.actionTarget;
                else if (p.role === 'hunter' && !p.hasUsedAbility) {
                    hunterShotTarget = p.actionTarget;
                    players[pid].hasUsedAbility = true;
                }
            }
        });

        let killedByWolvesId = Object.keys(wolfVotes).length > 0 ? Object.keys(wolfVotes).reduce((a, b) => wolfVotes[a] > wolfVotes[b] ? a : b) : null;
        const deaths = new Set();
        
        const devProtectTarget = devActions.protect;
        (devActions.kill || []).forEach(targetId => deaths.add(targetId));

        if (killedByWolvesId && killedByWolvesId !== doctorSaveTarget && killedByWolvesId !== devProtectTarget) {
            deaths.add(killedByWolvesId);
        } else if (killedByWolvesId && (killedByWolvesId === doctorSaveTarget || killedByWolvesId === devProtectTarget)) {
            events.push("An attack was attempted, but the target was saved by a protector!");
        }
        if (hunterShotTarget) deaths.add(hunterShotTarget);
        
        deaths.forEach(pid => {
            if (players[pid].isAlive) {
                players[pid].isAlive = false;
                events.push(`**${getDisplayName(players[pid])}** was found dead.`);
            }
        });

        if (events.length === 0) events.push("The night was quiet... No one died.");
        
        Object.keys(players).forEach(pid => { players[pid].actionTarget = null; });

        return {
            state: 'announcement',
            phase: 'day',
            players: players,
            announcement: { title: `Night ${turn} ended`, events: events, deaths: deaths.size > 0 },
            devActions: deleteField()
        };
    }

    function processDayVotes(roomData) {
        let { players, turn } = roomData;
        let events = [];
        const votes = {};
        const voteDetails = {};
        let skipVotes = 0;

        Object.entries(players).forEach(([voterId, p]) => {
            if (p.isAlive && p.votedFor) {
                const targetId = p.votedFor;
                if (targetId === '__SKIP__') {
                    skipVotes++;
                    return;
                }
                votes[targetId] = (votes[targetId] || 0) + 1;
                if (!voteDetails[targetId]) voteDetails[targetId] = [];
                voteDetails[targetId].push(getDisplayName(p));
            }
        });

        let eliminatedPlayerId = null;
        if (Object.keys(votes).length > 0) {
            const sortedVotes = Object.entries(votes).sort(([,a],[,b]) => b-a);
            if (sortedVotes[0][1] > skipVotes && (sortedVotes.length === 1 || sortedVotes[0][1] > sortedVotes[1][1])) {
                eliminatedPlayerId = sortedVotes[0][0];
            }
        }

        events.push("The votes are in:");
        Object.entries(players).filter(([,p])=>p.isAlive).forEach(([pid, p]) => {
            const voterList = voteDetails[pid] ? `(voted by ${voteDetails[pid].join(', ')})` : '';
            events.push(`**${getDisplayName(p)}**: ${votes[pid] || 0} votes ${voterList}`);
        });
        events.push(`**Skipped**: ${skipVotes} votes`);
        events.push("<hr class='my-2 border-gray-700'>");

        if (eliminatedPlayerId) {
            players[eliminatedPlayerId].isAlive = false;
            events.push(`**${getDisplayName(players[eliminatedPlayerId])}** was eliminated. Their role was **${players[eliminatedPlayerId].role}**.`);
        } else {
            events.push("The vote was tied or skipped. No one was eliminated.");
        }

        Object.keys(players).forEach(pid => { players[pid].votedFor = null; });

        return {
            state: 'announcement',
            phase: 'night',
            turn: turn + 1,
            players: players,
            announcement: { title: `Day ${turn} ended`, events: events, deaths: !!eliminatedPlayerId },
        };
    }

    function checkWinCondition(players) {
        const alivePlayers = Object.values(players).filter(p => p.isAlive);
        const aliveWolves = alivePlayers.filter(p => p.role === 'werewolf');
        const aliveVillagers = alivePlayers.filter(p => p.role !== 'werewolf');
        if (aliveWolves.length === 0) return { winningTeam: "Villagers", reason: "All werewolves have been eliminated!", players };
        if (aliveWolves.length >= aliveVillagers.length) return { winningTeam: "Werewolves", reason: "The werewolves have taken over the village!", players };
        return null;
    }

    async function startGame() {
        setLoading(true);
        const roomRef = doc(db, 'rooms', currentRoomId);
        try {
            await runTransaction(db, async (transaction) => {
                const roomDoc = await transaction.get(roomRef);
                if (!roomDoc.exists()) throw new Error("Room not found.");
                const roomData = roomDoc.data();
                const playerIds = Object.keys(roomData.players);
                playerOrder = [...playerIds].sort((a,b) => getDisplayName(roomData.players[a]).localeCompare(getDisplayName(roomData.players[b])));
                const settings = roomData.settings;
                let roles = Array(settings.numWerewolves).fill('werewolf');
                if (settings.includeSeer) roles.push('seer');
                if (settings.includeDoctor) roles.push('doctor');
                if (settings.includeHunter) roles.push('hunter');
                while (roles.length < playerIds.length) roles.push('villager');
                roles.sort(() => Math.random() - 0.5);

                const updatedPlayers = { ...roomData.players };
                playerIds.forEach((pid, index) => {
                    updatedPlayers[pid] = { ...updatedPlayers[pid], isAlive: true, role: roles[index], votedFor: null, actionTarget: null, hasUsedAbility: false, };
                });
                transaction.update(roomRef, {
                    state: 'role_reveal', players: updatedPlayers, turn: 1, phase: 'night',
                    phaseEndTime: Timestamp.fromMillis(Date.now() + 5000),
                    processing: false,
                });
            });
        } catch (e) {
            console.error("Start Game Error:", e);
            showToast("Failed to start game.", true);
        } finally { setLoading(false); }
    }
    
    function renderRoleReveal(roomData) {
        showScreen('game-screen');
        const myPlayerData = roomData.players[currentUser.uid];
        const roleInfo = {
            werewolf: { emoji: 'üê∫', desc: 'Each night, choose a player to eliminate with your pack.' },
            seer: { emoji: 'üëÅÔ∏è', desc: 'Each night, you may check one player to see their role.' },
            doctor: { emoji: 'üßë‚Äç‚öïÔ∏è', desc: 'Each night, you may choose one player to protect from attack.' },
            hunter: { emoji: 'üëÆ', desc: 'You have one bullet. At night, you can choose to shoot a player you think is a werewolf.' },
            villager: { emoji: 'üë±', desc: 'Work with your fellow villagers to find and eliminate the werewolves.' },
        };

        document.getElementById('role-reveal-emoji').textContent = roleInfo[myPlayerData.role].emoji;
        document.getElementById('role-reveal-name').textContent = `You are a ${myPlayerData.role.charAt(0).toUpperCase() + myPlayerData.role.slice(1)}`;
        document.getElementById('role-reveal-description').textContent = roleInfo[myPlayerData.role].desc;
        
        const alliesDiv = document.getElementById('role-reveal-allies');
        if (myPlayerData.role === 'werewolf') {
            const allies = Object.values(roomData.players).filter(p => p.role === 'werewolf' && p.nickname !== myPlayerData.nickname);
            if(allies.length > 0) {
                const allyNames = allies.map(a => getDisplayName(a));
                alliesDiv.innerHTML = `<p class="muted">Your fellow werewolves are: <strong>${allyNames.join(', ')}</strong></p>`;
            } else { alliesDiv.innerHTML = `<p class="muted">You are the lone wolf...</p>`; }
        } else { alliesDiv.innerHTML = ''; }

        showScreen('role-reveal-overlay');
        setTimeout(async () => {
            showScreen('role-reveal-overlay');
            if (localGameState.state !== 'role_reveal' || !currentRoomId) return;
            if (localGameState.hostId === currentUser.uid) {
                const roomRef = doc(db, 'rooms', currentRoomId);
                const duration = roomData.settings.nightDuration;
                const endTime = Timestamp.fromMillis(Date.now() + duration * 1000);
                await updateDoc(roomRef, { state: 'night', phaseEndTime: endTime });
            }
        }, 5000);
    }

    function renderAnnouncement(roomData) {
        showScreen('game-screen');
        const { title, events, deaths } = roomData.announcement;
        document.getElementById('event-title').textContent = title;
        document.getElementById('event-body').innerHTML = events.map(e => `<p>${e.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')}</p>`).join('');
        showModal('event-modal', true);
        if (deaths) {
            document.body.classList.add('shake');
            setTimeout(() => document.body.classList.remove('shake'), 500);
        }
        
        const ANNOUNCEMENT_DURATION = 12000;
        const roomRef = doc(db, 'rooms', currentRoomId);
        const hostTimeout = setTimeout(async () => {
            if (localGameState.hostId === currentUser.uid) {
                const duration = roomData.phase === 'day' ? roomData.settings.dayDuration : roomData.settings.nightDuration;
                const endTime = Timestamp.fromMillis(Date.now() + duration * 1000);
                await updateDoc(roomRef, { state: roomData.phase, phaseEndTime: endTime, announcement: null });
            }
        }, ANNOUNCEMENT_DURATION);

        document.getElementById('btn-close-event').onclick = async () => {
            clearTimeout(hostTimeout);
            showModal('event-modal', false);
            if (localGameState.hostId === currentUser.uid) {
                const duration = roomData.phase === 'day' ? roomData.settings.dayDuration : roomData.settings.nightDuration;
                const endTime = Timestamp.fromMillis(Date.now() + duration * 1000);
                await updateDoc(roomRef, { state: roomData.phase, phaseEndTime: endTime, announcement: null });
            }
        };
    }
    
    function renderGamePhase(roomData, oldState) {
        showScreen('game-screen');
        if(oldState !== roomData.state) playPhaseTransition(roomData.phase, roomData.turn);
        renderGamePlayerList(roomData);
        renderPlayerCards(roomData);
        updateTimer(roomData.phaseEndTime);
        
        const myData = roomData.players[currentUser.uid];
        const isNight = roomData.phase === 'night';
        
        document.getElementById('game-phase-title').textContent = `${isNight ? 'Night' : 'Day'} ${roomData.turn}`;
        document.getElementById('game-phase-subtitle').textContent = isNight ? "Make your move..." : "Discuss and vote!";
        document.getElementById('skip-vote-btn').classList.toggle('hidden', isNight || !myData.isAlive || myData.votedFor);

        const chatInput = document.getElementById('chat-input');
        const chatSend = document.getElementById('chat-send');
        const canChat = !isNight && (myData.isAlive || currentUser.isDeveloper);
        chatInput.disabled = !canChat;
        chatSend.disabled = !canChat;
        chatInput.placeholder = canChat ? 'Type a message...' : 'Chat is disabled.';
    }
    
    function renderPlayerCards(roomData) {
        const mainContent = document.getElementById('game-main-content');
        mainContent.innerHTML = '';
        const myData = roomData.players[currentUser.uid];
        const devActions = roomData.devActions || {};

        playerOrder.forEach(pid => {
            const p = roomData.players[pid];
            if (!p) return;
            const card = document.createElement('div');
            card.className = 'p-4 rounded-lg flex flex-col items-center justify-between text-center';
            card.style.background = 'var(--card)';
            card.style.border = '2px solid transparent';
            card.style.aspectRatio = '1 / 1.2';

            const isMe = pid === currentUser.uid;
            const displayName = getDisplayName(p);

            card.innerHTML = `
                <div>
                    <div class="text-4xl">${p.isAlive ? 'üôÇ' : 'üëª'}</div>
                    <strong class="mt-2 block">${displayName}</strong>
                    ${p.isDeveloper ? '<span class="shimmer-tag mt-1">Developer</span>' : ''}
                </div>
                <div class="flex flex-wrap justify-center gap-2 mt-3 text-2xl"></div>`;
            
            const actionsContainer = card.querySelector('.flex');
            
            if (roomData.phase === 'night') {
                if (currentUser.isDeveloper) {
                    if (p.isAlive && !isMe) {
                        actionsContainer.innerHTML += `<button title="Kill" class="p-1" onclick="performDevAction('${pid}', 'kill')">üî™</button>`;
                        actionsContainer.innerHTML += `<button title="Protect" class="p-1" onclick="performDevAction('${pid}', 'protect')">üõ°Ô∏è</button>`;
                    }
                    actionsContainer.innerHTML += `<button title="See Role" class="p-1" onclick="performDevAction('${pid}', 'seer')">üëÅÔ∏è</button>`;
                    if (!p.isAlive) {
                        actionsContainer.innerHTML += `<button title="Revive" class="p-1" onclick="performDevAction('${pid}', 'revive')">üíñ</button>`;
                    }
                } else if (p.isAlive && !isMe && myData.isAlive) {
                    if (myData.role === 'werewolf' || myData.role === 'hunter') actionsContainer.innerHTML += `<button title="Kill/Shoot" class="p-1" onclick="performNightAction('${pid}')">üî™</button>`;
                    if (myData.role === 'seer') actionsContainer.innerHTML += `<button title="See Role" class="p-1" onclick="performNightAction('${pid}')">üëÅÔ∏è</button>`;
                    if (myData.role === 'doctor') actionsContainer.innerHTML += `<button title="Protect" class="p-1" onclick="performNightAction('${pid}')">üõ°Ô∏è</button>`;
                }
            } else if (roomData.phase === 'day' && myData.isAlive && p.isAlive && !isMe && !myData.votedFor) {
                actionsContainer.innerHTML += `<button class="btn btn-primary px-4 text-sm" onclick="voteForPlayer('${pid}')">Vote</button>`;
            }
            
            if (!p.isAlive) card.style.opacity = '0.5';

            if (currentUser.isDeveloper) {
                if (devActions.kill && devActions.kill.includes(pid)) card.classList.add('targeted-kill');
                if (devActions.protect === pid) card.classList.add('targeted-protect');
            }
            if (myData.actionTarget === pid) {
                if (myData.role === 'werewolf' || myData.role === 'hunter') card.classList.add('targeted-kill');
                else if (myData.role === 'doctor') card.classList.add('targeted-protect');
            }
            if (myData.votedFor === pid) card.classList.add('targeted-vote');

            mainContent.appendChild(card);
        });
    }

    function renderGamePlayerList(roomData) {
        const list = document.getElementById('game-player-list');
        list.innerHTML = '';
        const myData = roomData.players[currentUser.uid];

        playerOrder.forEach(pid => {
            const p = roomData.players[pid];
            if (!p) return;
            const el = document.createElement('div');
            el.className = 'p-2 rounded-lg mb-2 flex justify-between items-center transition-all';
            const isMe = pid === currentUser.uid;
            const displayName = getDisplayName(p);
            
            let roleIndicator = '';
            const roleEmojis = {werewolf:'üê∫', seer:'üëÅÔ∏è', doctor:'üßë‚Äç‚öïÔ∏è', hunter: 'üëÆ', villager:'üë±'};
            if (currentUser.isDeveloper || isMe || (myData.isAlive && myData.role === 'werewolf' && p.role === 'werewolf')) {
                roleIndicator = roleEmojis[p.role];
            }
            let nickHTML = `<span class="font-bold">${displayName}</span>`;
            if (p.isDeveloper) nickHTML += ` <span class="shimmer-tag ml-2">Developer</span>`;
            el.innerHTML = `<div><span class="mr-2">${p.isAlive ? 'üôÇ' : 'üëª'}</span><span>${nickHTML} ${roleIndicator}</span></div>`;
            if (!p.isAlive) el.style.opacity = '0.5';
            if (isMe) el.style.background = 'rgba(125,125,125,0.1)';
            list.appendChild(el);
        });
        document.getElementById('developer-panel').classList.toggle('hidden', !currentUser.isDeveloper);
    }
    
    function renderGameOver(roomData) {
        const { winningTeam, reason, players } = roomData.gameOver;
        const title = `${winningTeam} Win!`;
        const body = `<p>${reason}</p><h4 class='mt-4'>Final Roles:</h4>` + 
            Object.values(players).map(p => {
                const displayName = getDisplayName(p);
                const roleEmoji = {werewolf:'üê∫', seer:'üëÅÔ∏è', doctor:'üßë‚Äç‚öïÔ∏è', hunter:'üëÆ', villager:'üë±'}[p.role] || '‚ùì';
                return `<p>${roleEmoji} ${displayName} was a ${p.role}</p>`;
            }).join('');
        
        document.getElementById('event-title').textContent = title;
        document.getElementById('event-body').innerHTML = body;
        document.getElementById('btn-close-event').textContent = "Back to Lobby";
        document.getElementById('btn-close-event').onclick = async () => {
            showModal('event-modal', false);
            if (localGameState.hostId === currentUser.uid) {
                await deleteDoc(doc(db, 'rooms', currentRoomId));
            }
            handleRoomClose();
        };
        showModal('event-modal', true);
    }

    async function performNightAction(targetId) {
        const myData = localGameState.players[currentUser.uid];
        const roomRef = doc(db, 'rooms', currentRoomId);
        
        if(myData.actionTarget === targetId) {
            showToast('Action cancelled.');
            return await updateDoc(roomRef, { [`players.${currentUser.uid}.actionTarget`]: deleteField() });
        }

        if (myData.role === 'seer') {
            const targetPlayer = localGameState.players[targetId];
            document.getElementById('seer-result-body').textContent = `${getDisplayName(targetPlayer)} is a ${targetPlayer.role}.`;
            showModal('seer-result-modal', true);
            showToast('Vision received.');
        } else {
            showToast('Action registered.');
            await updateDoc(roomRef, { [`players.${currentUser.uid}.actionTarget`]: targetId });
        }
    }

    async function performDevAction(targetId, actionType) {
        const roomRef = doc(db, 'rooms', currentRoomId);
        showToast(`Dev Action: ${actionType} on ${getDisplayName(localGameState.players[targetId])}`);
        
        if (actionType === 'revive') {
            return await updateDoc(roomRef, { [`players.${targetId}.isAlive`]: true });
        }
        if (actionType === 'seer') {
            const targetPlayer = localGameState.players[targetId];
            document.getElementById('seer-result-body').textContent = `${getDisplayName(targetPlayer)} is a ${targetPlayer.role}.`;
            return showModal('seer-result-modal', true);
        }
        
        await runTransaction(db, async (transaction) => {
            const roomDoc = await transaction.get(roomRef);
            if (!roomDoc.exists()) return;
            const currentActions = roomDoc.data().devActions || {};
            if (actionType === 'kill') {
                let killList = currentActions.kill || [];
                if (killList.includes(targetId)) {
                    killList = killList.filter(id => id !== targetId); // Cancel action
                } else {
                    killList.push(targetId);
                }
                currentActions.kill = killList;
            } else if (actionType === 'protect') {
                currentActions.protect = currentActions.protect === targetId ? null : targetId; // Cancel action
            }
            transaction.update(roomRef, { devActions: currentActions });
        });
    }

    async function voteForPlayer(targetId) {
        const myData = localGameState.players[currentUser.uid];
        const roomRef = doc(db, 'rooms', currentRoomId);

        if (myData.votedFor === targetId) {
            showToast('Vote cancelled.');
            return await updateDoc(roomRef, { [`players.${currentUser.uid}.votedFor`]: deleteField() });
        }
        
        showToast('Vote cast.');
        await updateDoc(roomRef, { [`players.${currentUser.uid}.votedFor`]: targetId });
    }
    
    async function sendMessage() {
        const input = document.getElementById('chat-input');
        const text = input.value.trim();
        if (!text) return;
        const chatRef = collection(db, 'rooms', currentRoomId, 'messages');
        await addDoc(chatRef, {
            uid: currentUser.uid, nickname: currentUser.displayName,
            isDeveloper: currentUser.isDeveloper, text: text, timestamp: serverTimestamp()
        });
        input.value = '';
    }
    
    function updateTimer(endTime) {
        if (gameTimerInterval) clearInterval(gameTimerInterval);
        const timerEl = document.getElementById('game-timer');
        if (!endTime || !endTime.seconds) { timerEl.textContent = '--:--'; return; }
        gameTimerInterval = setInterval(() => {
            const remaining = Math.max(0, Math.round((endTime.seconds * 1000 - Date.now()) / 1000));
            timerEl.textContent = `${String(Math.floor(remaining / 60)).padStart(2, '0')}:${String(remaining % 60).padStart(2, '0')}`;
            if (remaining <= 0) clearInterval(gameTimerInterval);
        }, 1000);
    }

    function playPhaseTransition(phase, turn) {
        const overlay = document.getElementById('phase-transition-overlay');
        const icon = document.getElementById('phase-icon');
        const title = document.getElementById('phase-title');
        
        if (phase === 'day') {
            overlay.className = 'day';
            icon.textContent = '‚òÄÔ∏è';
            title.textContent = `Day ${turn}`;
        } else {
            overlay.className = 'night';
            icon.textContent = 'üåô';
            title.textContent = `Night ${turn}`;
        }
        overlay.classList.add('visible');
        setTimeout(() => overlay.classList.remove('visible'), 2000);
    }

    function applyTheme(theme) {
        if (theme === 'light') {
            document.body.classList.add('light-theme');
        } else {
            document.body.classList.remove('light-theme');
        }
    }

    window.performNightAction = performNightAction;
    window.performDevAction = performDevAction;
    window.voteForPlayer = voteForPlayer;

    document.getElementById('btn-create-room').addEventListener('click', createRoom);
    document.getElementById('btn-join').addEventListener('click', ()=>{
      const code = document.getElementById('join-code').value.trim().toUpperCase();
      if(code) joinRoom(code); else showToast('Enter a room code', true);
    });
    document.getElementById('btn-leave').addEventListener('click', leaveRoom);
    document.querySelectorAll('.setting-input').forEach(input => input.addEventListener('change', updateSettingsInDb));
    document.getElementById('btn-start').addEventListener('click', startGame);
    document.getElementById('chat-send').addEventListener('click', sendMessage);
    document.getElementById('chat-input').addEventListener('keypress', (e) => { if (e.key === 'Enter') sendMessage(); });
    document.getElementById('skip-vote-btn').addEventListener('click', () => voteForPlayer('__SKIP__'));
    document.getElementById('dev-end-game').addEventListener('click', async () => {
        if (confirm("End game?")) {
            const roomRef = doc(db, 'rooms', currentRoomId);
            const roomData = (await getDoc(roomRef)).data();
            await updateDoc(roomRef, { 
                state: 'game_over',
                gameOver: { winningTeam: "Nobody", reason: "Game ended by a Developer.", players: roomData.players }
            });
        }
    });

    document.getElementById('theme-toggle-btn').addEventListener('click', () => {
        const isLight = document.body.classList.contains('light-theme');
        const newTheme = isLight ? 'dark' : 'light';
        localStorage.setItem('whoswolf-theme', newTheme);
        applyTheme(newTheme);
    });

    document.getElementById('btn-how-to-play').addEventListener('click', () => showModal('rules-modal-backdrop', true));
    document.getElementById('btn-close-rules').addEventListener('click', () => showModal('rules-modal-backdrop', false));

    (function init(){
      const savedTheme = localStorage.getItem('whoswolf-theme') || 'dark';
      applyTheme(savedTheme);
      initializeFirebase();
      const roomCode = new URLSearchParams(location.search).get('room');
      if (roomCode) document.getElementById('join-code').value = roomCode.toUpperCase();
    })();
  </script>
</body>
</html>