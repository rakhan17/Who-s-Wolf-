<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Who's Wolf</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üê∫</text></svg>">
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0b1220;
      --text: #e6eef8;
      --muted: #9ca3af;
      --card: rgba(255, 255, 255, 0.02);
      --border: rgba(148, 163, 184, 0.08);
      --card-gradient-start: rgba(255, 255, 255, 0.02);
      --card-gradient-end: rgba(255, 255, 255, 0.01);
      --team-wolf: #ef4444;
      --team-villager: #3b82f6;
      --team-neutral: #a855f7; /* New Neutral Color */
    }
    .light-theme {
      --bg: #f1f5f9;
      --text: #1e293b;
      --muted: #64748b;
      --card: #ffffff;
      --border: #e2e8f0;
      --card-gradient-start: #ffffff;
      --card-gradient-end: #f8fafc;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:'Poppins',system-ui,Segoe UI,Roboto; overflow: hidden; transition: background-color 0.3s, color 0.3s;}
    
    body.shake { animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both; }
    @keyframes shake { 10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-4px, 0, 0); } 40%, 60% { transform: translate3d(4px, 0, 0); } }

    body.night-phase-bg { animation: pulse-bg 10s ease-in-out infinite; }
    @keyframes pulse-bg { 0% { background-color: var(--bg); } 50% { background-color: #111827; } 100% { background-color: var(--bg); } }
    .light-theme.night-phase-bg { animation: pulse-bg-light 10s ease-in-out infinite; }
    @keyframes pulse-bg-light { 0% { background-color: var(--bg); } 50% { background-color: #e2e8f0; } 100% { background-color: var(--bg); } }

    body.timer-low-tension::before { content: ''; position: fixed; inset: 0; box-shadow: inset 0 0 20px 10px rgba(239, 68, 68, 0.5); pointer-events: none; animation: pulse-red-glow 1s infinite; z-index: 1000; }
    @keyframes pulse-red-glow { 0% { box-shadow: inset 0 0 20px 10px rgba(239, 68, 68, 0.3); opacity: 0.7; } 50% { box-shadow: inset 0 0 30px 15px rgba(239, 68, 68, 0.6); opacity: 1; } 100% { box-shadow: inset 0 0 20px 10px rgba(239, 68, 68, 0.3); opacity: 0.7; } }

    .screen{display:flex; align-items:center; justify-content:center; position:absolute; inset:0; padding:1rem; box-sizing:border-box; opacity:0; transition:opacity 0.4s ease-in-out; pointer-events:none;}
    .screen.active{ opacity:1; pointer-events:auto; }

    .card{background:linear-gradient(180deg, var(--card-gradient-start), var(--card-gradient-end));border-radius:14px;padding:24px;border:1px solid var(--border);box-shadow:0 8px 24px rgba(2,6,23,0.1); transition: background-color 0.3s, border-color 0.3s, box-shadow 0.3s;}
    .muted{color:var(--muted)}
    .input-wrapper{position:relative;width:100%;}
    .input-icon{position:absolute;left:12px;top:50%;transform:translateY(-50%);color:#94a3b8}
    input.input-field{width:100%;padding:12px 14px;border-radius:12px;background:transparent;border:1px solid var(--border);color:var(--text);outline:none}
    input.input-field.has-icon { padding-left: 44px; }
    .btn{display:inline-flex;align-items:center;justify-content:center;gap:.6rem;padding:.7rem 1rem;border-radius:12px;font-weight:700;cursor:pointer;border:0; transition: all 0.2s ease;}
    .btn:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .btn-primary{background:linear-gradient(90deg,#7c3aed,#4f46e5);color:white}
    .btn-secondary{background:#1f2937;color:#cbd5e1}
    .light-theme .btn-secondary { background: #e2e8f0; color: #334155; }
    .btn-danger{background:linear-gradient(90deg,#ef4444,#b91c1c);color:white}
    .btn-green{background:linear-gradient(90deg,#10b981,#06b6d4);color:white}
    .spinner{width:20px;height:20px;border-radius:50%;border:2px solid rgba(125,125,125,0.2);border-top-color:var(--text);animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
    
    .modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center;z-index:1000; opacity: 0; transition: opacity 0.3s ease; pointer-events:none;}
    .modal{min-width:280px;max-width:420px; opacity: 0; transform: scale(0.95); transition: all 0.3s ease;}
    .modal-backdrop.active { opacity: 1; pointer-events:auto; }
    .modal-backdrop.active .modal { opacity: 1; transform: scale(1); }
    #event-modal .modal { max-width: 520px; }
    #rules-modal-backdrop .modal { max-width: 640px; }

    #notification-toast {position: fixed; top: 20px; left: 50%; transform: translateX(-50%); padding: 12px 24px; border-radius: 10px; color: white; font-weight: 600; box-shadow: 0 4px 15px rgba(0,0,0,0.3); z-index: 10000; opacity: 0; transition: opacity 0.3s, top 0.3s; pointer-events: none;}
    #notification-toast.show { opacity: 1; top: 30px; }
    
    .hidden { display: none !important; }

    .shimmer-tag { font-size: 10px; font-weight: bold; padding: 2px 8px; border-radius: 5px; color: white; background: linear-gradient(270deg, #ff2d2d, #ff7b7b, #ff2d2d); background-size: 200% 200%; animation: shimmer 2s ease infinite; }
    @keyframes shimmer { 0%{background-position:200% 0} 100%{background-position:-200% 0} }

    .toggle-label { display: flex; align-items: center; justify-content: space-between; cursor: pointer; width: 100%; }
    .toggle-label input { display: none; }
    .toggle-switch { position: relative; display: inline-block; width: 40px; height: 22px; background-color: rgba(125,125,125,0.2); border-radius: 22px; transition: background-color 0.2s; }
    .toggle-switch::after { content: ''; position: absolute; width: 18px; height: 18px; border-radius: 50%; background-color: white; top: 2px; left: 2px; transition: transform 0.2s; }
    .toggle-label input:checked + .toggle-switch { background-color: #4f46e5; }
    .toggle-label input:checked + .toggle-switch::after { transform: translateX(18px); }

    .team-wolf { color: var(--team-wolf); }
    .team-villager { color: var(--team-villager); }
    .team-neutral { color: var(--team-neutral); } /* New Neutral Color Style */

    .targeted-vote { border: 2px solid #7c3aed !important; animation: pulse-vote 1.5s infinite; }
    @keyframes pulse-vote { 0% { box-shadow: 0 0 0 0 rgba(124, 58, 237, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(124, 58, 237, 0); } 100% { box-shadow: 0 0 0 0 rgba(124, 58, 237, 0); } }
    .targeted-kill { border: 2px solid #ef4444 !important; animation: pulse-red 1.5s infinite; }
    @keyframes pulse-red { 0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); } 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); } }
    .targeted-protect { border: 2px solid #22c55e !important; animation: pulse-green 1.5s infinite; }
    @keyframes pulse-green { 0% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(34, 197, 94, 0); } 100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0); } }

    #phase-transition-overlay { position: fixed; inset: 0; z-index: 9999; display: flex; flex-direction:column; align-items: center; justify-content: center; font-size: 8rem; color: white; pointer-events: none; opacity: 0; transition: opacity 0.5s ease-in-out; }
    #phase-transition-overlay.day { background: radial-gradient(circle, rgba(251,191,36,0.8) 0%, rgba(251,191,36,0) 70%); }
    #phase-transition-overlay.night { background: radial-gradient(circle, rgba(79,70,229,0.6) 0%, rgba(79,70,229,0) 70%); }
    #phase-transition-overlay.visible { opacity: 1; }
    #phase-title { font-size: 2rem; font-weight: bold; margin-top: -2rem; text-shadow: 0 2px 10px rgba(0,0,0,0.5); }
    .lag-indicator { font-size: 10px; font-weight: bold; padding: 2px 8px; border-radius: 5px; color: white; background: #f97316; margin-left: 8px; }

    .reveal-animation { animation: reveal 0.8s cubic-bezier(0.250, 0.460, 0.450, 0.940) both; }
    @keyframes reveal { 0% { transform: scale(0.5); opacity: 0; } 60% { transform: scale(1.1); } 80% { transform: scale(0.95); } 100% { transform: scale(1); opacity: 1; } }

    .alive-player-card { animation: breathe 4s ease-in-out infinite; }
    @keyframes breathe { 0%, 100% { transform: scale(1); box-shadow: 0 8px 24px rgba(2,6,23,0.1); } 50% { transform: scale(1.02); box-shadow: 0 10px 28px rgba(2,6,23,0.15); } }
    .my-card-glow { box-shadow: 0 0 15px rgba(79, 70, 229, 0.6) !important; border-color: rgba(124, 58, 237, 0.8) !important; }
  </style>
</head>
<body>
  <div id="phase-transition-overlay">
    <div id="phase-icon"></div>
    <div id="phase-title"></div>
  </div>

  <div id="notification-toast"></div>

  <div id="loading-overlay" class="screen active" data-screen-type="overlay" style="z-index:40; background: rgba(11, 18, 32, 0.8);">
    <div class="text-center">
      <div class="text-6xl">üê∫</div>
      <h1 class="text-3xl my-2">Who's Wolf?</h1>
      <div class="spinner w-8 h-8 border-3 mx-auto mt-5 mb-3"></div>
      <div class="muted">Connecting...</div>
    </div>
  </div>

  <div id="nickname-screen" class="screen" data-screen-type="main" style="z-index:10">
    <div class="card w-full max-w-md text-center">
      <div class="text-6xl">üê∫</div>
      <h1 class="text-3xl my-2">Welcome!</h1>
      <p class="muted">Enter your nickname to play</p>
      <div class="mt-4">
        <div class="input-wrapper mb-3"><span class="input-icon">üôç</span><input id="nickname-input" class="input-field has-icon" placeholder="Your Nickname" maxlength="25"></div>
        <button id="btn-enter-lobby" class="btn btn-primary w-full">Enter Lobby</button>
      </div>
    </div>
  </div>

  <div id="lobby-screen" class="screen" data-screen-type="main" style="z-index:15">
    <div class="card w-full max-w-4xl">
      <div class="flex flex-col sm:flex-row justify-between sm:items-center gap-4 pb-4 border-b" style="border-color: var(--border);">
        <div class="flex items-center gap-3">
            <div class="text-4xl">üê∫</div>
            <h2 class="m-0 text-2xl font-bold">Who's Wolf?</h2>
        </div>
        <div class="flex items-center justify-between sm:justify-end gap-4">
          <button id="theme-toggle-btn" class="btn btn-secondary p-2">üåì</button>
          <div id="welcome-container" class="text-right">
            <div class="flex items-center gap-2">
              <h2 id="welcome-text" class="m-0 text-lg"></h2>
              <button id="btn-edit-name" class="text-sm">‚úèÔ∏è</button>
            </div>
            <p class="muted m-0 text-xs">Ready to hunt?</p>
          </div>
          <button id="btn-how-to-play" class="btn btn-secondary">How to Play</button>
        </div>
      </div>

      <div id="pre-room-view" class="mt-6 flex flex-col items-center gap-6">
        <div class="text-center w-full max-w-xs">
          <h3 class="mt-0 mb-3 font-semibold">Create a New Room</h3>
          <button id="btn-create-room" class="btn btn-primary w-full">Create Room</button>
        </div>
        <div class="flex items-center gap-3 w-full max-w-xs" style="color: var(--muted);">
          <hr class="flex-1 border-0 border-t" style="border-color: var(--border);"><span class="text-sm">OR</span><hr class="flex-1 border-0 border-t" style="border-color: var(--border);">
        </div>
        <div class="text-center w-full max-w-xs">
          <h3 class="mt-0 mb-3 font-semibold">Join an Existing Room</h3>
          <div class="flex gap-2">
            <input id="join-code" class="input-field flex-1 uppercase" placeholder="ROOM CODE"/>
            <button id="btn-join" class="btn btn-green">Join</button>
          </div>
        </div>
      </div>

      <div id="in-room-view" class="hidden mt-3">
        <div class="flex justify-between items-center mb-3">
            <h3 class="m-0 text-lg">Room Code: <span id="room-code-display" class="text-purple-500 font-bold cursor-pointer"></span></h3>
            <button id="btn-leave" class="btn btn-secondary">Leave Room</button>
        </div>
        <div class="flex flex-col md:flex-row gap-4">
          <div class="flex-1">
            <h4 class="m-0 mb-2">Players (<span id="player-count">0</span>)</h4>
            <div id="player-list" class="min-h-[220px] max-h-[220px] md:max-h-[360px] overflow-auto rounded-lg p-2 bg-black bg-opacity-5"></div>
          </div>
          <div id="room-settings-panel" class="w-full md:w-80">
            <div class="card p-4">
              <h3 class="m-0 mb-3">Room Settings</h3>
              <div class="space-y-3">
                <div>
                  <label class="muted text-sm">Werewolves</label>
                  <input id="setting-wolves" type="number" min="1" value="1" class="input-field setting-input w-full mt-1"/>
                </div>
                <div class="grid grid-cols-2 gap-x-4 gap-y-2">
                  <label class="toggle-label muted text-sm"><span class="team-villager">Seer</span> <input id="setting-seer" type="checkbox" checked class="setting-input"><span class="toggle-switch"></span></label>
                  <label class="toggle-label muted text-sm"><span class="team-villager">Doctor</span> <input id="setting-doctor" type="checkbox" checked class="setting-input"><span class="toggle-switch"></span></label>
                  <label class="toggle-label muted text-sm"><span class="team-villager">Hunter</span> <input id="setting-hunter" type="checkbox" class="setting-input"><span class="toggle-switch"></span></label>
                  <label class="toggle-label muted text-sm"><span class="team-villager">Mayor</span> <input id="setting-mayor" type="checkbox" class="setting-input"><span class="toggle-switch"></span></label>
                  <label class="toggle-label muted text-sm"><span class="team-villager">Jailer</span> <input id="setting-jailer" type="checkbox" class="setting-input"><span class="toggle-switch"></span></label>
                  <label class="toggle-label muted text-sm"><span class="team-villager">Wild Child</span> <input id="setting-wildchild" type="checkbox" class="setting-input"><span class="toggle-switch"></span></label>
                  <label class="toggle-label muted text-sm"><span class="team-wolf">Alpha Wolf</span> <input id="setting-alphawolf" type="checkbox" class="setting-input"><span class="toggle-switch"></span></label>
                  <label class="toggle-label muted text-sm"><span class="team-wolf">Traitor</span> <input id="setting-traitor" type="checkbox" class="setting-input"><span class="toggle-switch"></span></label>
                  <label class="toggle-label muted text-sm"><span class="team-wolf">Mimic</span> <input id="setting-mimic" type="checkbox" class="setting-input"><span class="toggle-switch"></span></label>
                  <label class="toggle-label muted text-sm"><span class="team-neutral">Jester</span> <input id="setting-jester" type="checkbox" class="setting-input"><span class="toggle-switch"></span></label>
                  <label class="toggle-label muted text-sm"><span class="team-neutral">Arsonist</span> <input id="setting-arsonist" type="checkbox" class="setting-input"><span class="toggle-switch"></span></label>
                  <label class="toggle-label muted text-sm"><span class="team-neutral">Executioner</span> <input id="setting-executioner" type="checkbox" class="setting-input"><span class="toggle-switch"></span></label>
                  <label class="toggle-label muted text-sm">Reveal Role <input id="setting-reveal-role" type="checkbox" checked class="setting-input"><span class="toggle-switch"></span></label>
                </div>
                <div class="grid grid-cols-2 gap-4 pt-2">
                  <div>
                    <label class="muted text-sm">Day (s)</label>
                    <input id="setting-day" type="number" value="60" class="input-field setting-input w-full mt-1"/>
                  </div>
                  <div>
                    <label class="muted text-sm">Night (s)</label>
                    <input id="setting-night" type="number" value="45" class="input-field setting-input w-full mt-1"/>
                  </div>
                </div>
              </div>
            </div>
             <button id="btn-start" class="btn btn-primary hidden w-full mt-3">Start Game</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="game-screen" class="screen flex-col gap-4" data-screen-type="main">
    <div class="card w-full p-3 px-6 flex justify-between items-center">
      <div>
        <h2 id="game-phase-title" class="m-0 text-2xl">Night 1</h2>
        <p id="game-phase-subtitle" class="muted m-0 text-sm">The village is asleep...</p>
      </div>
      <div class="flex items-center gap-4">
        <button id="ignite-btn" class="btn btn-danger hidden">üî• Ignite All</button>
        <button id="skip-vote-btn" class="btn btn-secondary hidden">Skip Vote</button>
        <button id="reveal-mayor-btn" class="btn btn-primary hidden">Reveal as Mayor</button>
        <div class="text-center">
          <div id="game-timer" class="text-3xl font-bold transition-colors duration-300">00:45</div>
          <div id="timer-subtitle" class="muted text-xs">TIME REMAINING</div>
        </div>
      </div>
    </div>

    <div class="w-full flex-1 flex flex-col lg:flex-row gap-4 overflow-hidden">
      <div class="flex flex-col gap-4 w-full lg:w-72 order-2 lg:order-1 h-auto">
        <div class="card p-4 flex-1 flex flex-col">
          <h3 class="m-0 mb-2">Players</h3>
          <div id="game-player-list" class="overflow-y-auto flex-1"></div>
        </div>
        <div class="flex lg:flex-col gap-4">
            <div id="jailer-actions-panel" class="card hidden p-4 flex-1">
              <h4 class="m-0 mb-2">Jailer Actions</h4>
              <p id="jailed-player-name" class="muted text-sm mb-3"></p>
              <div class="space-y-2">
                <button id="jailer-interrogate-btn" class="btn btn-secondary w-full text-sm">Interrogate üí¨</button>
                <button id="jailer-execute-btn" class="btn btn-danger w-full text-sm">Execute ‚öñÔ∏è</button>
              </div>
            </div>
            <div id="developer-panel" class="card hidden p-4 flex-1">
              <h4 class="m-0 mb-2 text-red-400">Developer Tools</h4>
              <p class="muted text-xs">Use with caution!</p>
              <button id="dev-end-game" class="btn btn-secondary w-full text-xs mt-2">End Game</button>
            </div>
        </div>
      </div>

      <div id="game-main-content" class="card p-2 sm:p-4 flex-1 overflow-y-auto grid gap-2 sm:gap-4 grid-cols-3 md:grid-cols-4 content-start order-1 lg:order-2">
      </div>

      <div class="card p-4 w-full lg:w-80 flex flex-col order-3 h-64 lg:h-auto">
        <h3 class="m-0 mb-2">Room Chat</h3>
        <div id="chat-messages" class="flex-1 overflow-y-auto mb-2 text-sm"></div>
        <div class="flex gap-2">
          <input id="chat-input" class="input-field flex-1" placeholder="Type a message..." disabled/>
          <button id="chat-send" class="btn btn-primary" disabled>Send</button>
        </div>
      </div>
    </div>
  </div>

  <div id="role-reveal-overlay" class="screen" data-screen-type="overlay" style="z-index: 25; background: rgba(11, 18, 32, 0.9); text-align: center; color: white;">
      <div class="card">
        <div id="role-reveal-emoji" class="text-8xl mb-3"></div>
        <h1 id="role-reveal-name" class="text-3xl m-0"></h1>
        <p id="role-reveal-description" class="muted mt-2"></p>
        <div id="role-reveal-allies" class="mt-4"></div>
      </div>
  </div>
  
  <div id="seer-result-modal" class="modal-backdrop">
    <div class="modal card text-center">
        <h1 id="seer-result-title" class="text-3xl m-0">Seer's Vision</h1>
        <p id="seer-result-body" class="muted mt-4"></p>
        <button onclick="showModal('seer-result-modal', false)" class="btn btn-primary w-full mt-4">Close</button>
    </div>
  </div>

  <div id="jail-chat-modal" class="modal-backdrop">
    <div class="modal card flex flex-col h-[80vh] max-h-[500px]">
        <div class="flex justify-between items-center mb-3">
            <h1 id="jail-chat-title" class="text-2xl m-0">Interrogation</h1>
            <button onclick="showModal('jail-chat-modal', false)" class="text-2xl">&times;</button>
        </div>
        <div id="jail-chat-messages" class="flex-1 overflow-y-auto mb-2 text-sm bg-black bg-opacity-10 rounded-lg p-2"></div>
        <div class="flex gap-2">
            <input id="jail-chat-input" class="input-field flex-1" placeholder="Type a private message..."/>
            <button id="jail-chat-send" class="btn btn-primary">Send</button>
        </div>
    </div>
  </div>

  <div id="event-modal" class="modal-backdrop">
    <div class="modal card text-center">
        <h1 id="event-title" class="text-3xl m-0"></h1>
        <div id="event-body" class="muted mt-4 text-left"></div>
        <button id="btn-close-event" class="btn btn-primary w-full mt-4">Continue</button>
    </div>
  </div>

  <div id="rules-modal-backdrop" class="modal-backdrop">
    <div class="modal card">
        <h2 class="mt-0">How to Play Who's Wolf</h2>
        <p class="muted">The game is divided into two phases: Night and Day. The goal of the Villagers is to eliminate all Werewolves. The goal of the Werewolves is to outnumber the Villagers. Neutral roles have their own unique goals.</p>
        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 max-h-[60vh] overflow-y-auto p-2">
            <div><strong>üê∫ <span class="team-wolf">Werewolf</span></strong><p class="muted text-sm">During the night, wake up with fellow werewolves to choose one player to eliminate.</p></div>
            <div><strong>üë± <span class="team-villager">Villager</span></strong><p class="muted text-sm">During the day, discuss and vote to eliminate a player you suspect is a werewolf.</p></div>
            <div><strong>üëÅÔ∏è <span class="team-villager">Seer</span></strong><p class="muted text-sm">During the night, you can choose one player to learn their true identity (Werewolf or not).</p></div>
            <div><strong>üßë‚Äç‚öïÔ∏è <span class="team-villager">Doctor</span></strong><p class="muted text-sm">During the night, you can choose one player to protect from a werewolf attack for that night.</p></div>
            <div><strong>üëÆ <span class="team-villager">Hunter</span></strong><p class="muted text-sm">You have one bullet. At night, you can choose to shoot a player you think is a werewolf.</p></div>
            <div><strong>üéñÔ∏è <span class="team-villager">Mayor</span></strong><p class="muted text-sm">Your vote is absolute after you reveal your role during the day.</p></div>
            <div><strong>üóùÔ∏è <span class="team-villager">Jailer</span></strong><p class="muted text-sm">Each night, you can imprison a player. They are protected but cannot act. You can privately chat and execute them once per game.</p></div>
            <div><strong>üßí <span class="team-villager">Wild Child</span></strong><p class="muted text-sm">On night 1, choose a role model. If they die, you become a Werewolf.</p></div>
            <div><strong>üê∫üëë <span class="team-wolf">Alpha Wolf</span></strong><p class="muted text-sm">You are a Werewolf, but the Seer sees you as a Villager.</p></div>
            <div><strong>üé≠ <span class="team-wolf">Traitor</span></strong><p class="muted text-sm">You are a Villager who knows the Werewolves and wins with them. The Seer sees you as a Villager.</p></div>
            <div><strong>ü¶ú <span class="team-wolf">Mimic</span></strong><p class="muted text-sm">You win with the Werewolves. If a Seer exists, you receive their vision each night, causing confusion.</p></div>
            <div><strong>ü§° <span class="team-neutral">Jester</span></strong><p class="muted text-sm">You are a neutral role. Your goal is to get yourself eliminated by voting during the day. If you succeed, you win alone.</p></div>
            <div><strong>üî• <span class="team-neutral">Arsonist</span></strong><p class="muted text-sm">Neutral role. Each night, douse a player with gasoline. Instead of dousing, you can ignite all doused players. Win by being the last one alive.</p></div>
            <div><strong>ü™ì <span class="team-neutral">Executioner</span></strong><p class="muted text-sm">Neutral role. You are assigned a Villager as a target. Win by convincing the town to eliminate them. If your target dies at night, you become a Jester.</p></div>
        </div>
        <div class="text-right mt-5">
            <button id="btn-close-rules" class="btn btn-primary">Got it!</button>
        </div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js';
    import { getAuth, onAuthStateChanged, signInAnonymously, updateProfile } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js';
    import { getFirestore, doc, collection, setDoc, getDoc, runTransaction, onSnapshot, deleteField, updateDoc, deleteDoc, serverTimestamp, query, orderBy, addDoc, where, Timestamp, arrayUnion, arrayRemove } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js';

    const mainScreens = document.querySelectorAll('[data-screen-type="main"]');
    function setActiveScreen(id){ 
        mainScreens.forEach(s => s.classList.toggle('active', s.id === id)); 
    }
    function showOverlay(id, show = true) {
        const overlayEl = document.getElementById(id);
        if (overlayEl) overlayEl.classList.toggle('active', show);
    }

    function setLoading(on){ 
        showOverlay('loading-overlay', on);
    }
    function showToast(msg, err=false){
      const t = document.getElementById('notification-toast');
      t.textContent = msg;
      t.style.background = err ? 'linear-gradient(90deg,#ef4444,#f97316)' : 'linear-gradient(90deg,#10b981,#06b6d4)';
      t.classList.add('show');
      setTimeout(()=> t.classList.remove('show'), 3000);
    }
    window.showModal = (id, show) => {
        document.getElementById(id)?.classList.toggle('active', show);
    }

    let auth, db;
    // NOTE: This is a public Firebase config. No sensitive data is stored here.
    const firebaseConfig = {
      apiKey: "AIzaSyCsPjYivo2bQp-fsr5wcdBfTRIiAcSbJNo",
      authDomain: "who-s-wolf.firebaseapp.com",
      projectId: "who-s-wolf",
      storageBucket: "who-s-wolf.appspot.com",
      messagingSenderId: "981640498887",
      appId: "1:981640498887:web:92e582b23c6588d48a78e2",
    };

    function initializeFirebase() {
        try {
            const app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            handleAuthentication();
        } catch(e) {
            console.error("Firebase Init Error:", e);
            showToast('Failed to initialize application.', true);
        }
    }

    let currentUser = null;
    const DEV_PREFIX = "[slnana]";
    
    function getDisplayName(playerOrNickname) {
        let nickname = '';
        if (typeof playerOrNickname === 'string') {
            nickname = playerOrNickname;
        } else if (playerOrNickname && playerOrNickname.nickname) {
            nickname = playerOrNickname.nickname;
        }

        if (nickname.toLowerCase().startsWith(DEV_PREFIX)) {
            return nickname.substring(DEV_PREFIX.length).trim();
        }
        return nickname;
    }

    async function handleAuthentication() {
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                const isDev = user.displayName?.toLowerCase().startsWith(DEV_PREFIX) || false;
                currentUser = { 
                    uid: user.uid, 
                    displayName: user.displayName,
                    isDeveloper: isDev
                };
                if (user.displayName) {
                    updateWelcomeText(user.displayName);
                    setActiveScreen('lobby-screen');
                } else {
                    setActiveScreen('nickname-screen');
                }
                setLoading(false);
            } else {
                try { 
                    setLoading(true);
                    await signInAnonymously(auth); 
                } catch (error) {
                    console.error("Anonymous Sign In Error:", error);
                    showToast('Failed to connect to server.', true);
                }
            }
        });
    }
    
    function updateWelcomeText(name) {
        const displayName = getDisplayName(name);
        const welcomeTextEl = document.getElementById('welcome-text');
        welcomeTextEl.textContent = displayName;
        if (name.toLowerCase().startsWith(DEV_PREFIX)) {
            const devTag = document.createElement('span');
            devTag.className = 'shimmer-tag ml-2';
            devTag.textContent = 'Developer';
            welcomeTextEl.appendChild(devTag);
        }
    }

    async function setNickname(nickname) {
        if (!nickname) { showToast('Nickname cannot be empty!', true); return false; }
        setLoading(true);
        try {
            await updateProfile(auth.currentUser, { displayName: nickname });
            currentUser.displayName = nickname;
            currentUser.isDeveloper = nickname.toLowerCase().startsWith(DEV_PREFIX);
            updateWelcomeText(nickname);
            setActiveScreen('lobby-screen');
            return true;
        } catch (error) {
            console.error("Update Profile Error:", error);
            showToast('Failed to save nickname.', true);
            return false;
        } finally { setLoading(false); }
    }

    document.getElementById('btn-enter-lobby').addEventListener('click', () => {
        setNickname(document.getElementById('nickname-input').value.trim());
    });
    document.getElementById('btn-edit-name').addEventListener('click', () => {
        const newName = prompt("Enter new nickname:", currentUser.displayName);
        if (newName) setNickname(newName.trim());
    });

    let currentRoomId = null;
    let roomUnsub = null;
    let chatUnsub = null;
    let gameTimerInterval = null;
    let presenceInterval = null;
    let localGameState = {};
    let playerOrder = [];
    let isProcessingPhase = false;
    let modalQueue = [];
    let isModalActive = false;

    function setLobbyView(inRoom) {
        document.getElementById('pre-room-view').classList.toggle('hidden', inRoom);
        document.getElementById('in-room-view').classList.toggle('hidden', !inRoom);
    }
    
    function startPresenceUpdates() {
        if (presenceInterval) clearInterval(presenceInterval);
        presenceInterval = setInterval(async () => {
            if (currentRoomId && currentUser && db) {
                const roomRef = doc(db, 'rooms', currentRoomId);
                try { await updateDoc(roomRef, { [`players.${currentUser.uid}.lastSeen`]: serverTimestamp() }); } catch (e) { /* Fail silently */ }
            }
        }, 15000);
    }

    function stopPresenceUpdates() {
        if (presenceInterval) clearInterval(presenceInterval);
        presenceInterval = null;
    }

    async function createRoom(){
      setLoading(true);
      try {
        const code = Math.random().toString(36).substring(2,8).toUpperCase();
        const roomRef = doc(db, 'rooms', code);
        await setDoc(roomRef, { 
            hostId: currentUser.uid, 
            players: { [currentUser.uid]: { nickname: currentUser.displayName, isHost: true, isDeveloper: currentUser.isDeveloper, lastSeen: serverTimestamp() } }, 
            settings: getSettingsFromUI(), state: 'lobby', createdAt: serverTimestamp()
        });
        currentRoomId = code;
        try { window.history.replaceState({}, '', '?room=' + code); } catch (e) { console.warn("Could not update URL:", e); }
        subscribeToRoom(code);
        showToast('Room created: ' + code);
      } catch(e){
        console.error("Create Room Error:", e);
        showToast('Failed to create room.', true);
      } finally { setLoading(false); }
    }

    async function joinRoom(code){
      setLoading(true);
      try {
        const roomRef = doc(db, "rooms", code);
        await runTransaction(db, async (transaction) => {
            const roomDoc = await transaction.get(roomRef);
            if (!roomDoc.exists()) throw new Error("Room not found!");
            const roomData = roomDoc.data();
            if (roomData.state !== 'lobby') throw new Error("Game has already started!");
            transaction.update(roomRef, { [`players.${currentUser.uid}`]: { nickname: currentUser.displayName, isHost: false, isDeveloper: currentUser.isDeveloper, lastSeen: serverTimestamp() } });
        });
        currentRoomId = code;
        try { window.history.replaceState({}, '', '?room=' + code); } catch (e) { console.warn("Could not update URL:", e); }
        subscribeToRoom(code);
        showToast('Joined ' + code);
      } catch (error) {
          console.error("Join Room Error:", error);
          showToast(`Failed to join: ${error.message}`, true);
      } finally { setLoading(false); }
    }

    function subscribeToRoom(code){
      if(roomUnsub) roomUnsub();
      startPresenceUpdates();
      const roomRef = doc(db, 'rooms', code);
      roomUnsub = onSnapshot(roomRef, snap => {
        if(!snap.exists()){
          showToast('Room closed.', true);
          handleRoomClose();
          return;
        }
        const roomData = snap.data();
        const oldState = localGameState.state;
        const myOldData = localGameState.players ? localGameState.players[currentUser.uid] : null;
        const myNewData = roomData.players ? roomData.players[currentUser.uid] : null;

        if (oldState !== undefined && !myNewData) {
            showToast("You were kicked or the room was closed.", true);
            handleRoomClose();
            return;
        }
        
        if (myNewData && myNewData.privateMessage && (!myOldData || myNewData.privateMessage !== myOldData.privateMessage)) {
            showToast(myNewData.privateMessage);
            updateDoc(doc(db, 'rooms', currentRoomId), { [`players.${currentUser.uid}.privateMessage`]: deleteField() });
        }
        
        const oldJailedPlayerId = localGameState.jailedPlayerId;
        const newJailedPlayerId = roomData.jailedPlayerId;
        
        if (newJailedPlayerId && currentUser.uid === roomData.jailerId) {
            document.getElementById('jailer-actions-panel').classList.remove('hidden');
            document.getElementById('jailed-player-name').textContent = `Jailed: ${getDisplayName(roomData.players[newJailedPlayerId])}`;
            document.getElementById('jailer-execute-btn').disabled = myNewData.executionsLeft === 0;
        } else {
            document.getElementById('jailer-actions-panel').classList.add('hidden');
        }

        if (newJailedPlayerId && (currentUser.uid === newJailedPlayerId || currentUser.uid === roomData.jailerId)) {
            if (!oldJailedPlayerId) { 
                showModal('jail-chat-modal', true);
            }
            renderJailChat(roomData);
        } else if (oldJailedPlayerId && !newJailedPlayerId) {
            showModal('jail-chat-modal', false);
        }

        if (roomData.players) {
            playerOrder = Object.keys(roomData.players).sort((a,b) => getDisplayName(roomData.players[a]).localeCompare(getDisplayName(roomData.players[b])));
        }
        
        localGameState = roomData;
        
        if (roomData.hostId === currentUser.uid && roomData.state !== 'lobby' && !roomData.processing) {
            hostGameLogic(roomData);
        }

        if (roomData.state === 'lobby' && oldState !== 'lobby' && oldState !== undefined) {
            setActiveScreen('lobby-screen');
            renderLobbyView(roomData);
            return;
        }

        switch(roomData.state) {
            case 'lobby': setActiveScreen('lobby-screen'); renderLobbyView(roomData); break;
            case 'role_reveal': renderRoleReveal(roomData, oldState); break;
            case 'night': case 'day': renderGamePhase(roomData, oldState); break;
            case 'announcement': renderAnnouncement(roomData, oldState); break;
            case 'game_over': renderGameOver(roomData); break;
        }
      }, err => {
        console.error("Room subscription error:", err);
        showToast('Connection to room lost.', true);
        handleRoomClose();
      });
      subscribeToChat(code);
    }
    
    function subscribeToChat(code) {
        if (chatUnsub) chatUnsub();
        const chatRef = collection(db, 'rooms', code, 'messages');
        const q = query(chatRef, orderBy('timestamp', 'asc'));
        chatUnsub = onSnapshot(q, (snapshot) => {
            const chatMessages = document.getElementById('chat-messages');
            chatMessages.innerHTML = '';
            snapshot.forEach(doc => {
                const msg = doc.data();
                const msgEl = document.createElement('div');
                const displayName = getDisplayName(msg);
                let nickHTML = `<strong>${displayName}</strong>`;
                if(msg.isDeveloper) nickHTML += ` <span class="shimmer-tag ml-2">Developer</span>`;
                msgEl.innerHTML = `<p class="mb-1">${nickHTML}: ${msg.text}</p>`;
                chatMessages.appendChild(msgEl);
            });
            chatMessages.scrollTop = chatMessages.scrollHeight;
        });
    }

    async function leaveRoom(){
      if(currentRoomId){
        const roomRef = doc(db, "rooms", currentRoomId);
        try {
            const roomDoc = await getDoc(roomRef);
            if (roomDoc.exists()) {
                const roomData = roomDoc.data();
                const isHost = roomData.hostId === currentUser.uid;
                if (isHost || Object.keys(roomData.players).length <= 1) {
                    await deleteDoc(roomRef);
                } else {
                    await updateDoc(roomRef, { [`players.${currentUser.uid}`]: deleteField() });
                }
            }
        } catch(e){ console.error('Leave Room Error:', e); }
      }
      handleRoomClose();
    }
    
    function handleRoomClose() {
        if(roomUnsub){ roomUnsub(); roomUnsub = null; }
        if(chatUnsub){ chatUnsub(); chatUnsub = null; }
        stopPresenceUpdates();
        currentRoomId = null;
        playerOrder = [];
        if(gameTimerInterval) clearInterval(gameTimerInterval);
        try { window.history.replaceState({}, '', location.pathname); } catch (e) { console.warn("Could not update URL:", e); }
        setLobbyView(false);
        setActiveScreen('lobby-screen');
    }
    
    async function kickPlayer(playerIdToKick) {
        if (!currentRoomId) return;
        const roomRef = doc(db, "rooms", currentRoomId);
        try {
            await updateDoc(roomRef, { [`players.${playerIdToKick}`]: deleteField() });
            showToast("Player kicked successfully.");
        } catch (e) { console.error("Kick Player Error:", e); showToast("Failed to kick player.", true); }
    }

    function renderLobbyView(roomData){
      setLobbyView(true);
      const codeDisplay = document.getElementById('room-code-display');
      codeDisplay.textContent = currentRoomId || '----';
      codeDisplay.onclick = () => {
          navigator.clipboard.writeText(currentRoomId).then(() => showToast('Room code copied!'), () => showToast('Failed to copy code.', true));
      };

      const list = document.getElementById('player-list');
      list.innerHTML = '';
      const players = roomData.players || {};
      const playerIds = Object.keys(players);
      document.getElementById('player-count').textContent = playerIds.length;
      const isCurrentUserHost = roomData.hostId === currentUser.uid;

      playerIds.sort((a,b) => getDisplayName(players[a]).localeCompare(getDisplayName(players[b]))).forEach(pid => {
        const p = players[pid];
        const el = document.createElement('div');
        el.className = 'flex justify-between items-center p-2 rounded-lg mb-2';
        const displayName = getDisplayName(p);
        const isOnline = p.lastSeen && (Date.now() / 1000 - p.lastSeen.seconds < 30);
        let statusHTML = '';
        if (!isOnline) {
            statusHTML = `<span class="lag-indicator">Lag</span>`;
        }
        let nickHTML = `<strong>${displayName} ${p.isHost ? 'üëë' : ''}</strong>`;
        if(p.isDeveloper) nickHTML += ` <span class="shimmer-tag ml-2">Developer</span>`;
        const nameDiv = document.createElement('div');
        nameDiv.innerHTML = `<div>${nickHTML}</div><div>${statusHTML}</div>`;
        nameDiv.className = 'flex items-center';
        el.appendChild(nameDiv);

        if ((isCurrentUserHost || currentUser.isDeveloper) && pid !== currentUser.uid && !p.isHost) {
            const kickBtn = document.createElement('button');
            kickBtn.textContent = 'Kick';
            kickBtn.className = 'btn btn-danger text-xs px-2 py-1';
            kickBtn.onclick = () => { if(confirm(`Are you sure you want to kick ${displayName}?`)) kickPlayer(pid); };
            el.appendChild(kickBtn);
        }
        list.appendChild(el);
      });

      document.getElementById('room-settings-panel').style.display = 'block'; // Always show
      document.getElementById('btn-start').classList.toggle('hidden', !isCurrentUserHost || playerIds.length < 3);
      updateSettingsUI(roomData.settings, !isCurrentUserHost);
    }
    
    function getSettingsFromUI() {
        return {
            numWerewolves: parseInt(document.getElementById('setting-wolves').value || 1),
            includeSeer: document.getElementById('setting-seer').checked,
            includeDoctor: document.getElementById('setting-doctor').checked,
            includeHunter: document.getElementById('setting-hunter').checked,
            includeMayor: document.getElementById('setting-mayor').checked,
            includeJailer: document.getElementById('setting-jailer').checked,
            includeWildChild: document.getElementById('setting-wildchild').checked,
            includeAlphaWolf: document.getElementById('setting-alphawolf').checked,
            includeTraitor: document.getElementById('setting-traitor').checked,
            includeMimic: document.getElementById('setting-mimic').checked,
            includeJester: document.getElementById('setting-jester').checked,
            includeArsonist: document.getElementById('setting-arsonist').checked,
            includeExecutioner: document.getElementById('setting-executioner').checked,
            revealRoleOnDeath: document.getElementById('setting-reveal-role').checked,
            dayDuration: parseInt(document.getElementById('setting-day').value || 60),
            nightDuration: parseInt(document.getElementById('setting-night').value || 45)
        };
    }
    function updateSettingsUI(settings, disableInputs) {
        if (!settings) return;
        document.getElementById('setting-wolves').value = settings.numWerewolves;
        document.getElementById('setting-seer').checked = settings.includeSeer;
        document.getElementById('setting-doctor').checked = settings.includeDoctor;
        document.getElementById('setting-hunter').checked = settings.includeHunter;
        document.getElementById('setting-mayor').checked = settings.includeMayor ?? false;
        document.getElementById('setting-jailer').checked = settings.includeJailer ?? false;
        document.getElementById('setting-wildchild').checked = settings.includeWildChild ?? false;
        document.getElementById('setting-alphawolf').checked = settings.includeAlphaWolf ?? false;
        document.getElementById('setting-traitor').checked = settings.includeTraitor ?? false;
        document.getElementById('setting-mimic').checked = settings.includeMimic ?? false;
        document.getElementById('setting-jester').checked = settings.includeJester ?? false;
        document.getElementById('setting-arsonist').checked = settings.includeArsonist ?? false;
        document.getElementById('setting-executioner').checked = settings.includeExecutioner ?? false;
        document.getElementById('setting-reveal-role').checked = settings.revealRoleOnDeath ?? true;
        document.getElementById('setting-day').value = settings.dayDuration;
        document.getElementById('setting-night').value = settings.nightDuration;
        document.querySelectorAll('.setting-input').forEach(input => input.disabled = disableInputs);
    }
    
    async function updateSettingsInDb() {
        if (!currentRoomId || !currentUser.uid) return;
        const roomRef = doc(db,'rooms', currentRoomId);
        try {
            const snap = await getDoc(roomRef);
            if (snap.exists() && snap.data().hostId === currentUser.uid) {
                await updateDoc(roomRef, { settings: getSettingsFromUI() });
            }
        } catch (e) { console.error("Update Settings Error:", e); showToast("Failed to save settings.", true); }
    }

    async function hostGameLogic(roomData) {
        const roomRef = doc(db, 'rooms', currentRoomId);
        const { state, players, phaseEndTime, announcementEndTime, mayorVoteCast } = roomData;

        if ((state === 'announcement' || state === 'role_reveal') && announcementEndTime && Timestamp.now().seconds > announcementEndTime.seconds) {
            await updateDoc(roomRef, { processing: true });
            
            const winState = checkWinCondition(players);
            if (winState) {
                await updateDoc(roomRef, { state: 'game_over', gameOver: winState, processing: false });
                return;
            }

            const nextPhase = roomData.phase;
            const duration = nextPhase === 'day' ? roomData.settings.dayDuration : roomData.settings.nightDuration;
            const endTime = Timestamp.fromMillis(Date.now() + duration * 1000);
            
            const updates = {
                state: nextPhase,
                phaseEndTime: endTime,
                announcement: null,
                announcementEndTime: deleteField(),
                processing: false,
                jailedPlayerId: deleteField(),
                jailerId: deleteField(),
                jailChatMessages: deleteField(),
                mayorVoteCast: deleteField(),
            };
            if (nextPhase === 'night') {
                Object.keys(players).forEach(pid => {
                    if (players[pid].role === 'seer') {
                        updates[`players.${pid}.hasUsedAbilityThisTurn`] = false;
                    }
                    if (players[pid].role === 'arsonist') {
                        // Arsonist ability cooldown
                        updates[`players.${pid}.abilityCooldown`] = Math.max(0, (players[pid].abilityCooldown || 0) - 1);
                    }
                });
            }

            await updateDoc(roomRef, updates);
            return;
        }

        if (state === 'day') {
            const alivePlayers = Object.values(players).filter(p => p.isAlive);
            const allVoted = alivePlayers.every(p => p.votedFor);
            if ((allVoted && alivePlayers.length > 0) || mayorVoteCast) {
                 await updateDoc(roomRef, { processing: true });
                 const nextStateData = processDayVotes(roomData);
                 if (nextStateData.state === 'game_over') {
                     await updateDoc(roomRef, { ...nextStateData, processing: false });
                     return;
                 }
                 const ANNOUNCEMENT_DURATION_MS = 12000;
                 await updateDoc(roomRef, { 
                     ...nextStateData, 
                     announcementEndTime: Timestamp.fromMillis(Date.now() + ANNOUNCEMENT_DURATION_MS),
                     processing: false 
                 });
                 return;
            }
        }

        if ((state === 'night' || state === 'day') && phaseEndTime && Timestamp.now().seconds > phaseEndTime.seconds) {
            await updateDoc(roomRef, { processing: true });
            let nextStateData = {};
            
            if (state === 'night') {
                nextStateData = processNightActions(roomData);
            } else { // day
                nextStateData = processDayVotes(roomData);
                if (nextStateData.state === 'game_over') {
                    await updateDoc(roomRef, { ...nextStateData, processing: false });
                    return;
                }
            }
            
            const ANNOUNCEMENT_DURATION_MS = 12000;
            await updateDoc(roomRef, { 
                ...nextStateData, 
                announcementEndTime: Timestamp.fromMillis(Date.now() + ANNOUNCEMENT_DURATION_MS),
                processing: false 
            });
        }
    }
    
    function processNightActions(roomData) {
        let { players, turn, devActions = {}, settings } = roomData;
        let updatedPlayers = JSON.parse(JSON.stringify(players));
        let events = [];
        const potentialDeaths = new Set();
        
        let jailedPlayerId = null;
        let jailerId = null;
        const jailerAction = Object.entries(updatedPlayers).find(([pid, p]) => p.isAlive && p.role === 'jailer' && p.actionTarget);
        if (jailerAction) {
            jailerId = jailerAction[0];
            const targetId = jailerAction[1].actionTarget;
            if (targetId.startsWith('execute_')) {
                jailedPlayerId = targetId.substring(8);
                if (updatedPlayers[jailerId].executionsLeft > 0) {
                    potentialDeaths.add(jailedPlayerId);
                    updatedPlayers[jailerId].executionsLeft = 0;
                    events.push(`The Jailer has decided to execute their prisoner!`);
                }
            } else {
                jailedPlayerId = targetId;
            }
            events.push(`**${getDisplayName(updatedPlayers[jailedPlayerId])}** has been hauled off to jail!`);
        }

        const arsonist = Object.entries(updatedPlayers).find(([pid, p]) => p.isAlive && p.role === 'arsonist' && p.actionTarget === '__IGNITE__');
        if (arsonist) {
            events.push("A fire engulfs the village!");
            Object.entries(updatedPlayers).forEach(([pid, p]) => {
                if (p.isDoused && pid !== jailedPlayerId) {
                    potentialDeaths.add(pid);
                }
            });
        }

        const wolfVotes = {};
        let doctorSaveTarget = null;
        let hunterShotTarget = null;
        Object.entries(updatedPlayers).forEach(([pid, p]) => {
            if (!p.isAlive || pid === jailedPlayerId || !p.actionTarget || p.actionTarget === '__IGNITE__') return;
            
            if (p.role === 'werewolf') wolfVotes[p.actionTarget] = (wolfVotes[p.actionTarget] || 0) + 1;
            else if (p.role === 'doctor') doctorSaveTarget = p.actionTarget;
            else if (p.role === 'hunter' && !p.hasUsedAbility) {
                hunterShotTarget = p.actionTarget;
                updatedPlayers[pid].hasUsedAbility = true;
            }
        });

        let killedByWolvesId = Object.keys(wolfVotes).length > 0 ? Object.keys(wolfVotes).reduce((a, b) => wolfVotes[a] > wolfVotes[b] ? a : b) : null;
        
        const attacks = new Set();
        if (killedByWolvesId) attacks.add(killedByWolvesId);
        if (hunterShotTarget) attacks.add(hunterShotTarget);
        (devActions.kill || []).forEach(targetId => attacks.add(targetId));

        attacks.forEach(targetId => {
            const target = updatedPlayers[targetId];
            if (targetId === jailedPlayerId) return; 
            if (target.role === 'arsonist' || target.role === 'executioner') return; 
            potentialDeaths.add(targetId);
        });
        
        const actuallyDied = new Set();
        const devProtectTarget = devActions.protect;
        potentialDeaths.forEach(pid => {
            if (pid === doctorSaveTarget || pid === devProtectTarget) {
                events.push(`An attack on **${getDisplayName(updatedPlayers[pid])}** was thwarted by a protector!`);
            } else {
                if (updatedPlayers[pid] && updatedPlayers[pid].isAlive) {
                    updatedPlayers[pid].isAlive = false;
                    actuallyDied.add(pid);
                    let deathMessage = `**${getDisplayName(updatedPlayers[pid])}** was found dead.`;
                    if (settings.revealRoleOnDeath) {
                        deathMessage += ` Their role was **${updatedPlayers[pid].role}**.`;
                    }
                    events.push(deathMessage);
                }
            }
        });

        let wildChildChanged = false;
        actuallyDied.forEach(deadPlayerId => {
             Object.entries(updatedPlayers).forEach(([p_id, p_data]) => {
                if (p_data.role === 'wildChild' && p_data.roleModel === deadPlayerId) {
                    updatedPlayers[p_id].role = 'werewolf';
                    wildChildChanged = true;
                }
                if (p_data.role === 'executioner' && p_data.targetId === deadPlayerId) {
                    updatedPlayers[p_id].role = 'jester';
                    updatedPlayers[p_id].privateMessage = "Your target died at night! You are now a Jester. Get yourself eliminated to win.";
                }
            });
        });
        if (wildChildChanged && settings.revealRoleOnDeath) {
            events.push(`Devastated by their role model's death, a **Wild Child** has joined the werewolves!`);
        }
        
        if (events.length === 0) events.push("The night was quiet... No one died.");
        Object.keys(updatedPlayers).forEach(pid => { updatedPlayers[pid].actionTarget = null; });

        return {
            state: 'announcement',
            phase: 'day',
            players: updatedPlayers,
            announcement: { title: `Night ${turn} ended`, events: events, deaths: actuallyDied.size > 0 },
            devActions: deleteField()
        };
    }

    function processDayVotes(roomData) {
        let { players, turn, settings, mayorVoteCast } = roomData;
        let updatedPlayers = JSON.parse(JSON.stringify(players));
        let events = [];
        const votes = {};
        const voteDetails = {};
        let skipVotes = 0;
        const revealRole = settings.revealRoleOnDeath ?? true;
        let wildChildChanged = false;
        let eliminatedPlayerId = null;

        if (mayorVoteCast) {
            const mayor = Object.values(updatedPlayers).find(p => p.role === 'mayor' && p.isMayorRevealed);
            if (mayor && mayor.votedFor && mayor.votedFor !== '__SKIP__') {
                eliminatedPlayerId = mayor.votedFor;
                events.push(`The Mayor has made a final decision!`);
            }
        } else {
            Object.entries(updatedPlayers).forEach(([voterId, p]) => {
                if (p.isAlive && p.votedFor) {
                    const targetId = p.votedFor;
                    const voteWeight = 1; // Mayor is absolute, so weight is 1 for tally
                    if (targetId === '__SKIP__') {
                        skipVotes += voteWeight;
                        return;
                    }
                    votes[targetId] = (votes[targetId] || 0) + voteWeight;
                    if (!voteDetails[targetId]) voteDetails[targetId] = [];
                    voteDetails[targetId].push(getDisplayName(p));
                }
            });
            
            if (Object.keys(votes).length > 0) {
                const sortedVotes = Object.entries(votes).sort(([,a],[,b]) => b-a);
                if (sortedVotes[0][1] > skipVotes && (sortedVotes.length === 1 || sortedVotes[0][1] > sortedVotes[1][1])) {
                    eliminatedPlayerId = sortedVotes[0][0];
                }
            }

            events.push("The votes are in:");
            playerOrder.forEach(pid => {
                const p = updatedPlayers[pid];
                if (p && p.isAlive) {
                    const voterList = voteDetails[pid] ? `(voted by ${voteDetails[pid].join(', ')})` : '';
                    events.push(`**${getDisplayName(p)}**: ${votes[pid] || 0} votes ${voterList}`);
                }
            });
            events.push(`**Skipped**: ${skipVotes} votes`);
            events.push("<hr class='my-2 border-gray-700'>");
        }
        
        if (eliminatedPlayerId && updatedPlayers[eliminatedPlayerId].role === 'jester') {
             return {
                state: 'game_over',
                gameOver: {
                    winningTeam: "Jester",
                    reason: `**${getDisplayName(updatedPlayers[eliminatedPlayerId])}** tricked everyone into eliminating them!`,
                    players
                }
            };
        }

        if (eliminatedPlayerId) {
            updatedPlayers[eliminatedPlayerId].isAlive = false;
            let eliminationMessage = `**${getDisplayName(updatedPlayers[eliminatedPlayerId])}** was eliminated.`;
            if (revealRole) {
                eliminationMessage += ` Their role was **${updatedPlayers[eliminatedPlayerId].role}**.`;
            }
            events.push(eliminationMessage);

            Object.entries(updatedPlayers).forEach(([p_id, p_data]) => {
                if (p_data.role === 'executioner' && p_data.targetId === eliminatedPlayerId) {
                    updatedPlayers[p_id].missionComplete = true;
                    events.push(`**${getDisplayName(p_data)}** the Executioner has completed their goal!`);
                }
                if (p_data.role === 'wildChild' && p_data.roleModel === eliminatedPlayerId) {
                    updatedPlayers[p_id].role = 'werewolf';
                    wildChildChanged = true;
                }
            });
        } else {
            events.push("The vote was tied or skipped. No one was eliminated.");
        }

        if (wildChildChanged && revealRole) {
            events.push(`Devastated by their role model's death, a **Wild Child** has joined the werewolves!`);
        }

        Object.keys(updatedPlayers).forEach(pid => { updatedPlayers[pid].votedFor = null; });

        return {
            state: 'announcement',
            phase: 'night',
            turn: turn + 1,
            players: updatedPlayers,
            announcement: { title: `Day ${turn} ended`, events: events, deaths: !!eliminatedPlayerId },
        };
    }

    function checkWinCondition(players) {
        const alivePlayers = Object.values(players).filter(p => p.isAlive);
        if (alivePlayers.length === 0) return null;
        
        const aliveArsonist = alivePlayers.find(p => p.role === 'arsonist');
        if (aliveArsonist && alivePlayers.length === 1) {
            return { winningTeam: "Arsonist", reason: "Only the Arsonist remains!", players };
        }

        const wolfTeamRoles = ['werewolf', 'traitor', 'mimic'];
        const aliveWolfTeam = alivePlayers.filter(p => wolfTeamRoles.includes(p.role));
        const aliveNonWolfTeam = alivePlayers.filter(p => !wolfTeamRoles.includes(p.role));

        if (aliveWolfTeam.length === 0 && alivePlayers.some(p => !wolfTeamRoles.includes(p.role) && p.role !== 'arsonist')) {
             return { winningTeam: "Villagers", reason: "All werewolves have been eliminated!", players };
        }
        if (aliveWolfTeam.length >= aliveNonWolfTeam.length) {
            return { winningTeam: "Werewolves", reason: "The werewolves have taken over the village!", players };
        }
        return null;
    }

    async function startGame() {
        setLoading(true);
        const roomRef = doc(db, 'rooms', currentRoomId);
        try {
            await runTransaction(db, async (transaction) => {
                const roomDoc = await transaction.get(roomRef);
                if (!roomDoc.exists()) throw new Error("Room not found.");
                const roomData = roomDoc.data();
                const playerIds = Object.keys(roomData.players);
                const settings = roomData.settings;
                
                const wolfTeamRoles = ['werewolf', 'traitor', 'mimic'];
                const villagerTeamRoles = ['villager', 'seer', 'doctor', 'hunter', 'mayor', 'jailer', 'wildChild'];
                
                let rolesToAssign = [];
                let isBalanced = false;
                let attempts = 0;

                do {
                    rolesToAssign = [];
                    if (settings.includeSeer) rolesToAssign.push('seer');
                    if (settings.includeDoctor) rolesToAssign.push('doctor');
                    if (settings.includeHunter) rolesToAssign.push('hunter');
                    if (settings.includeMayor) rolesToAssign.push('mayor');
                    if (settings.includeJailer) rolesToAssign.push('jailer');
                    if (settings.includeWildChild) rolesToAssign.push('wildChild');
                    if (settings.includeTraitor) rolesToAssign.push('traitor');
                    if (settings.includeMimic) rolesToAssign.push('mimic');
                    if (settings.includeJester) rolesToAssign.push('jester');
                    if (settings.includeArsonist) rolesToAssign.push('arsonist');
                    if (settings.includeExecutioner) rolesToAssign.push('executioner');
                    
                    for (let i = 0; i < settings.numWerewolves; i++) {
                        rolesToAssign.push('werewolf');
                    }

                    while (rolesToAssign.length < playerIds.length) {
                        rolesToAssign.push('villager');
                    }
                    
                    rolesToAssign.sort(() => Math.random() - 0.5);

                    const wolfCount = rolesToAssign.filter(r => wolfTeamRoles.includes(r)).length;
                    const nonWolfCount = rolesToAssign.length - wolfCount;
                    
                    isBalanced = wolfCount < nonWolfCount;
                    attempts++;

                } while (!isBalanced && attempts < 20);

                if (!isBalanced) {
                    throw new Error("Could not create a balanced game. Please adjust role settings.");
                }

                const updatedPlayers = { ...roomData.players };
                const wolfIds = [];
                const villagerTeamIdsForTarget = [];

                playerIds.forEach((pid, index) => {
                    const role = rolesToAssign[index];
                    updatedPlayers[pid] = { 
                        ...updatedPlayers[pid], 
                        isAlive: true, 
                        role: role, 
                        votedFor: null, 
                        actionTarget: null, 
                        hasUsedAbility: false,
                        hasUsedAbilityThisTurn: false,
                        isMayorRevealed: false,
                        isDoused: false,
                        abilityCooldown: 0,
                        targetId: null,
                        missionComplete: false,
                        executionsLeft: role === 'jailer' ? 1 : 0,
                    };
                    if (role === 'werewolf') {
                        wolfIds.push(pid);
                    }
                    if (villagerTeamRoles.includes(role)) {
                        villagerTeamIdsForTarget.push(pid);
                    }
                });

                const executionerId = playerIds.find(pid => updatedPlayers[pid].role === 'executioner');
                if (executionerId && villagerTeamIdsForTarget.length > 0) {
                    const targetId = villagerTeamIdsForTarget[Math.floor(Math.random() * villagerTeamIdsForTarget.length)];
                    updatedPlayers[executionerId].targetId = targetId;
                }

                if (settings.includeAlphaWolf && wolfIds.length > 0) {
                    const alphaIndex = Math.floor(Math.random() * wolfIds.length);
                    const alphaId = wolfIds[alphaIndex];
                    updatedPlayers[alphaId].isAlpha = true;
                }
                playerIds.forEach(pid => {
                    if (updatedPlayers[pid].role === 'traitor') {
                        updatedPlayers[pid].knowsWolves = wolfIds.map(id => getDisplayName(updatedPlayers[id]));
                    }
                });
                
                const ROLE_REVEAL_DURATION_MS = 8000;
                transaction.update(roomRef, {
                    state: 'role_reveal', 
                    players: updatedPlayers, 
                    turn: 1, 
                    phase: 'night',
                    announcementEndTime: Timestamp.fromMillis(Date.now() + ROLE_REVEAL_DURATION_MS),
                    processing: false,
                });
            });
        } catch (e) {
            console.error("Start Game Error:", e);
            showToast(e.message || "Failed to start game.", true);
        } finally { setLoading(false); }
    }
    
    function renderRoleReveal(roomData, oldState) {
        setActiveScreen('game-screen');
        showOverlay('role-reveal-overlay');
        
        if (oldState !== 'role_reveal') {
            const card = document.querySelector('#role-reveal-overlay .card');
            card.classList.remove('reveal-animation');
            void card.offsetWidth;
            card.classList.add('reveal-animation');
        }

        const myPlayerData = roomData.players[currentUser.uid];
        const roleInfo = {
            werewolf: { emoji: myPlayerData.isAlpha ? 'üê∫üëë' : 'üê∫', desc: 'Each night, choose a player to eliminate with your pack.' },
            seer: { emoji: 'üëÅÔ∏è', desc: 'Each night, you may check one player to see if they are a werewolf.' },
            doctor: { emoji: 'ÔøΩ‚Äç‚öïÔ∏è', desc: 'Each night, you may choose one player to protect from attack.' },
            hunter: { emoji: 'üëÆ', desc: 'You have one bullet. At night, you can choose to shoot a player you think is a werewolf.' },
            villager: { emoji: 'üë±', desc: 'Work with your fellow villagers to find and eliminate the werewolves.' },
            mayor: { emoji: 'üéñÔ∏è', desc: 'Your vote is absolute after you reveal your role during the day.' },
            jailer: { emoji: 'üóùÔ∏è', desc: 'Each night, imprison a player. You can privately interrogate and execute them once.' },
            wildChild: { emoji: 'üßí', desc: 'On the first night, choose a role model. If they die, you become a werewolf.' },
            traitor: { emoji: 'üé≠', desc: 'You are a villager who wins with the werewolves. Deceive everyone.' },
            mimic: { emoji: 'ü¶ú', desc: 'You win with the werewolves. If a Seer exists, you will receive their visions.' },
            jester: { emoji: 'ü§°', desc: 'You are neutral. Your goal is to get yourself eliminated by voting. You win alone.' },
            arsonist: { emoji: 'üî•', desc: 'You are neutral. Douse players at night, then ignite them all. Be the last one standing.' },
            executioner: { emoji: 'ü™ì', desc: 'You are neutral. Your goal is to convince the village to eliminate your assigned target.' },
        };

        let roleName = myPlayerData.role.charAt(0).toUpperCase() + myPlayerData.role.slice(1);
        if (myPlayerData.isAlpha) roleName = 'Alpha Wolf';
        if (myPlayerData.role === 'wildChild') roleName = 'Wild Child';

        document.getElementById('role-reveal-emoji').textContent = roleInfo[myPlayerData.role].emoji;
        document.getElementById('role-reveal-name').textContent = `You are a ${roleName}`;
        document.getElementById('role-reveal-description').textContent = roleInfo[myPlayerData.role].desc;
        
        const alliesDiv = document.getElementById('role-reveal-allies');
        alliesDiv.innerHTML = '';
        if (myPlayerData.role === 'werewolf' || myPlayerData.role === 'mimic') {
            const allies = Object.values(roomData.players).filter(p => p.role === 'werewolf' && p.nickname !== myPlayerData.nickname);
            if(allies.length > 0) {
                const allyNames = allies.map(a => getDisplayName(a));
                alliesDiv.innerHTML = `<p class="muted">Your fellow werewolves are: <strong>${allyNames.join(', ')}</strong></p>`;
            } else { alliesDiv.innerHTML = `<p class="muted">You are the lone wolf...</p>`; }
        } else if (myPlayerData.role === 'traitor') {
             if(myPlayerData.knowsWolves.length > 0) {
                alliesDiv.innerHTML = `<p class="muted">The werewolves are: <strong>${myPlayerData.knowsWolves.join(', ')}</strong></p>`;
            } else { alliesDiv.innerHTML = `<p class="muted">There are no werewolves to help...</p>`; }
        } else if (myPlayerData.role === 'executioner') {
            if (myPlayerData.targetId) {
                const targetName = getDisplayName(roomData.players[myPlayerData.targetId]);
                alliesDiv.innerHTML = `<p class="muted">Your target is: <strong class="team-villager">${targetName}</strong>. Convince the village to eliminate them.</p>`;
            }
        }
    }

    function renderAnnouncement(roomData, oldState) {
        if (oldState !== 'announcement') {
            const { title, events, deaths } = roomData.announcement;
            document.getElementById('event-title').textContent = title;
            document.getElementById('event-body').innerHTML = events.map(e => `<p>${e.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')}</p>`).join('');
            
            document.getElementById('btn-close-event').onclick = () => {
                showModal('event-modal', false);
                processModalQueue();
            };
            
            queueModal({
                type: 'event',
                onShow: () => {
                    if (deaths) {
                        document.body.classList.add('shake');
                        setTimeout(() => document.body.classList.remove('shake'), 500);
                    }
                }
            });
        }
    }
    
    function renderGamePhase(roomData, oldState) {
        setActiveScreen('game-screen');
        
        isProcessingPhase = false; 
        const myData = roomData.players[currentUser.uid];
        const isNight = roomData.state === 'night';
        document.body.classList.toggle('night-phase-bg', isNight);

        if(oldState !== roomData.state && oldState !== 'role_reveal' && oldState !== 'announcement') {
            queueModal({ type: 'phase', phase: roomData.state, turn: roomData.turn });
        }
        renderGamePlayerList(roomData);
        renderPlayerCards(roomData);
        updateTimer(roomData.phaseEndTime, roomData.state, roomData.mayorVoteCast);
        
        document.getElementById('game-phase-title').textContent = `${isNight ? 'Night' : 'Day'} ${roomData.turn}`;
        document.getElementById('game-phase-subtitle').textContent = isNight ? "Make your move..." : "Discuss and vote!";
        
        const skipVoteBtn = document.getElementById('skip-vote-btn');
        skipVoteBtn.classList.toggle('hidden', isNight || !myData.isAlive || (myData.role === 'mayor' && myData.isMayorRevealed));
        if (myData.votedFor === '__SKIP__') {
            skipVoteBtn.textContent = 'Cancel Skip';
        } else {
            skipVoteBtn.textContent = 'Skip Vote';
        }

        document.getElementById('reveal-mayor-btn').classList.toggle('hidden', isNight || !myData.isAlive || myData.role !== 'mayor' || myData.isMayorRevealed);
        const hasDousedPlayers = Object.values(roomData.players).some(p => p.isDoused);
        document.getElementById('ignite-btn').classList.toggle('hidden', !isNight || !myData.isAlive || myData.role !== 'arsonist' || !hasDousedPlayers || myData.actionTarget);

        const chatInput = document.getElementById('chat-input');
        const chatSend = document.getElementById('chat-send');
        const canChat = !isNight && (myData.isAlive || currentUser.isDeveloper);
        chatInput.disabled = !canChat;
        chatSend.disabled = !canChat;

        let placeholderText = 'Type a message...';
        if (isNight) {
            placeholderText = 'Chat is disabled at night.';
        } else if (!myData.isAlive && !currentUser.isDeveloper) {
            placeholderText = 'You cannot chat, you are dead.';
        }
        chatInput.placeholder = placeholderText;
    }
    
    function renderPlayerCards(roomData) {
        const mainContent = document.getElementById('game-main-content');
        mainContent.innerHTML = '';
        const myData = roomData.players[currentUser.uid];
        const devActions = roomData.devActions || {};

        playerOrder.forEach(pid => {
            const p = roomData.players[pid];
            if (!p) return;
            const card = document.createElement('div');
            card.className = 'p-2 rounded-lg flex flex-col items-center justify-between text-center transition-transform hover:scale-105 hover:-translate-y-1 card';
            card.style.border = '2px solid transparent';
            card.style.aspectRatio = '1 / 1';

            const isMe = pid === currentUser.uid;
            const displayName = getDisplayName(p);

            card.innerHTML = `
                <div>
                    <div class="text-4xl relative">
                        <span>${p.isAlive ? (roomData.jailedPlayerId === pid ? '‚õìÔ∏è' : 'üë±') : 'üíÄ'}</span>
                        ${(myData.role === 'arsonist' && p.isDoused) ? '<span class="absolute text-2xl -top-1 -right-1" title="Doused">‚õΩ</span>' : ''}
                    </div>
                    <strong class="mt-2 block text-sm">${displayName}</strong>
                    ${p.isDeveloper ? '<span class="shimmer-tag mt-1">Developer</span>' : ''}
                </div>
                <div class="dev-actions-container flex justify-center gap-2 mt-2 text-xl"></div>
                <div class="player-actions-container flex flex-wrap justify-center gap-2 mt-2"></div>`;
            
            const devActionsContainer = card.querySelector('.dev-actions-container');
            const playerActionsContainer = card.querySelector('.player-actions-container');
            
            if (isProcessingPhase || (roomData.jailedPlayerId && myData.role !== 'jailer')) {
                // No actions for most players if someone is jailed
            } else if (roomData.state === 'night') {
                const actionButton = (title, icon, action, targetId) => `<button title="${title}" class="p-1 text-2xl" onclick="${action}('${targetId}')">${icon}</button>`;
                
                if (currentUser.isDeveloper) {
                    if (p.isAlive && !isMe) {
                        devActionsContainer.innerHTML += actionButton('Kill', 'üî™', 'performDevAction', `${pid},kill`);
                        devActionsContainer.innerHTML += actionButton('Protect', 'üõ°Ô∏è', 'performDevAction', `${pid},protect`);
                    }
                    devActionsContainer.innerHTML += actionButton('See Role', 'üëÅÔ∏è', 'performDevAction', `${pid},seer`);
                    if (!p.isAlive) {
                        devActionsContainer.innerHTML += actionButton('Revive', 'üíñ', 'performDevAction', `${pid},revive`);
                    }
                } 
                
                if (p.isAlive && myData.isAlive && !myData.actionTarget) {
                    const devRolesWithSameAction = { werewolf: 'kill', doctor: 'protect', hunter: 'kill' };
                    const shouldShowRoleAction = !currentUser.isDeveloper || !Object.values(devRolesWithSameAction).includes(myData.role);

                    if ((myData.role === 'werewolf' || (myData.role === 'hunter' && !myData.hasUsedAbility)) && shouldShowRoleAction) {
                        if (!isMe) playerActionsContainer.innerHTML += actionButton('Kill/Shoot', 'üî™', 'performNightAction', pid);
                    }
                    if (myData.role === 'seer' && shouldShowRoleAction) {
                        if (!isMe) playerActionsContainer.innerHTML += actionButton('See Role', 'üëÅÔ∏è', 'performNightAction', pid);
                    }
                    if (myData.role === 'doctor' && shouldShowRoleAction) {
                        playerActionsContainer.innerHTML += actionButton('Protect', 'üõ°Ô∏è', 'performNightAction', pid);
                    }
                    if (myData.role === 'wildChild' && roomData.turn === 1 && !myData.roleModel) {
                        if (!isMe) playerActionsContainer.innerHTML += actionButton('Choose Model', 'üéØ', 'selectRoleModel', pid);
                    }
                    if (myData.role === 'arsonist' && myData.abilityCooldown === 0) {
                        if (!isMe && !p.isDoused) playerActionsContainer.innerHTML += actionButton('Douse', '‚õΩ', 'performNightAction', pid);
                    }
                    if (myData.role === 'jailer' && !roomData.jailedPlayerId) {
                        if (!isMe) {
                             playerActionsContainer.innerHTML += actionButton('Jail', 'üóùÔ∏è', 'performNightAction', pid);
                        }
                    }
                }
            } else if (roomData.state === 'day' && myData.isAlive && p.isAlive) {
                 if (!isMe && !roomData.mayorVoteCast) {
                    playerActionsContainer.innerHTML += `<button class="btn btn-primary px-3 py-1 text-xs" onclick="voteForPlayer('${pid}')">${myData.votedFor === pid ? 'Cancel' : 'Vote'}</button>`;
                 } else if (myData.role === 'mayor' && myData.isMayorRevealed && !roomData.mayorVoteCast) {
                    playerActionsContainer.innerHTML += `<button class="btn btn-primary px-3 py-1 text-xs" onclick="voteForPlayer('${pid}')">Vote</button>`;
                 }
            }
            
            if (p.isAlive) {
                card.classList.add('alive-player-card');
                if (isMe) card.classList.add('my-card-glow');
            } else {
                card.style.opacity = '0.5';
            }

            if (currentUser.isDeveloper) {
                if (devActions.kill && devActions.kill.includes(pid)) card.classList.add('targeted-kill');
                if (devActions.protect === pid) card.classList.add('targeted-protect');
            }
            if (myData.actionTarget === pid || myData.roleModel === pid || myData.actionTarget === `execute_${pid}`) {
                if (['werewolf', 'hunter', 'arsonist', 'jailer'].includes(myData.role)) card.classList.add('targeted-kill');
                else if (myData.role === 'doctor') card.classList.add('targeted-protect');
                else if (myData.role === 'wildChild') card.classList.add('targeted-vote');
            }
            if (myData.votedFor === pid) card.classList.add('targeted-vote');

            mainContent.appendChild(card);
        });
    }

    function renderGamePlayerList(roomData) {
        const list = document.getElementById('game-player-list');
        list.innerHTML = '';
        const myData = roomData.players[currentUser.uid];

        playerOrder.forEach(pid => {
            const p = roomData.players[pid];
            if (!p) return;
            const el = document.createElement('div');
            el.className = 'p-2 rounded-lg mb-2 flex justify-between items-center transition-all text-sm';
            const isMe = pid === currentUser.uid;
            const displayName = getDisplayName(p);
            
            let roleIndicator = '';
            const roleEmojis = {werewolf:'üê∫', seer:'üëÅÔ∏è', doctor:'üßë‚Äç‚öïÔ∏è', hunter: 'üëÆ', villager:'üë±', mayor: 'üéñÔ∏è', jailer: 'üóùÔ∏è', wildChild: 'üßí', traitor: 'üé≠', mimic: 'ü¶ú', jester: 'ü§°', arsonist: 'üî•', executioner: 'ü™ì'};
            if (p.isAlpha) roleEmojis.werewolf = 'üê∫üëë';

            if (currentUser.isDeveloper || isMe || (!p.isAlive && (myData.role === 'werewolf' || myData.role === 'mimic') && p.role === 'werewolf')) {
                roleIndicator = roleEmojis[p.role];
            }
            
            let nickHTML = `<span class="font-bold">${displayName}</span>`;
            if (p.isDeveloper) nickHTML += ` <span class="shimmer-tag ml-2">Developer</span>`;
            if (p.isMayorRevealed) nickHTML += 'üéñÔ∏è';
            
            const voteIndicator = (roomData.state === 'day' && p.isAlive && p.votedFor) ? '‚úÖ' : '';

            el.innerHTML = `<div><span class="mr-2">${p.isAlive ? (roomData.jailedPlayerId === pid ? '‚õìÔ∏è' : 'üë±') : 'üíÄ'}</span><span>${nickHTML} ${roleIndicator}</span></div><div class="text-lg">${voteIndicator}</div>`;
            if (!p.isAlive) el.style.opacity = '0.5';
            if (isMe) el.style.background = 'rgba(125,125,125,0.1)';
            list.appendChild(el);
        });
        document.getElementById('developer-panel').classList.toggle('hidden', !currentUser.isDeveloper);
    }
    
    function renderGameOver(roomData) {
        const { winningTeam, reason, players } = roomData.gameOver;
        const teamColors = { "Werewolves": "team-wolf", "Villagers": "team-villager", "Jester": "team-neutral", "Arsonist": "team-neutral", "Executioner": "team-neutral" };
        const teamColorClass = teamColors[winningTeam] || '';
        const title = `<span class="${teamColorClass}">${winningTeam} Win!</span>`;
        
        let additionalWinners = '';
        Object.values(players).forEach(p => {
            if (p.role === 'executioner' && p.missionComplete) {
                additionalWinners += `<p class="team-neutral">**${getDisplayName(p)}** the Executioner also wins!</p>`;
            }
        });

        const body = `<p>${reason}</p>${additionalWinners}<h4 class='mt-4'>Final Roles:</h4>` + 
            playerOrder.map(pid => {
                const p = players[pid];
                if (!p) return '';
                const displayName = getDisplayName(p);
                let roleName = p.role;
                if (p.isAlpha) roleName = 'Alpha Wolf';
                if (p.role === 'wildChild') roleName = 'Wild Child';

                const wolfTeamRoles = ['werewolf', 'traitor', 'mimic'];
                const neutralRoles = ['jester', 'arsonist', 'executioner'];
                let nameColorClass = 'team-villager';
                if (wolfTeamRoles.includes(p.role)) nameColorClass = 'team-wolf';
                if (neutralRoles.includes(p.role)) nameColorClass = 'team-neutral';

                const roleEmoji = {werewolf: p.isAlpha ? 'üê∫üëë' : 'üê∫', seer:'üëÅÔ∏è', doctor:'üßë‚Äç‚öïÔ∏è', hunter:'üëÆ', villager:'üë±', mayor: 'üéñÔ∏è', jailer: 'üóùÔ∏è', wildChild: 'üßí', traitor: 'üé≠', mimic: 'ü¶ú', jester: 'ü§°', arsonist: 'üî•', executioner: 'ü™ì'}[p.role] || '‚ùì';
                return `<p>${roleEmoji} <span class="${nameColorClass}">${displayName}</span> was a ${roleName}</p>`;
            }).join('');
        
        document.getElementById('event-title').innerHTML = title;
        document.getElementById('event-body').innerHTML = body;
        document.getElementById('btn-close-event').textContent = "Back to Lobby";
        document.getElementById('btn-close-event').onclick = () => {
            showModal('event-modal', false);
            handleRoomClose();
        };
        showModal('event-modal', true);
    }

    async function performNightAction(targetId) {
        const myData = localGameState.players[currentUser.uid];
        const roomRef = doc(db, 'rooms', currentRoomId);
        
        if(myData.actionTarget === targetId) {
            showToast('Action cancelled.');
            return await updateDoc(roomRef, { [`players.${currentUser.uid}.actionTarget`]: deleteField() });
        }
        
        if (myData.role === 'arsonist') {
            if (targetId === '__IGNITE__') {
                showToast('Ignition scheduled!');
                return await updateDoc(roomRef, { [`players.${currentUser.uid}.actionTarget`]: '__IGNITE__' });
            } else {
                showToast(`Doused ${getDisplayName(localGameState.players[targetId])}.`);
                return await updateDoc(roomRef, { 
                    [`players.${targetId}.isDoused`]: true,
                    [`players.${currentUser.uid}.actionTarget`]: targetId,
                    [`players.${currentUser.uid}.abilityCooldown`]: 2 // Cooldown for 2 turns (this night + next night)
                });
            }
        }

        const updates = { [`players.${currentUser.uid}.actionTarget`]: targetId };
        
        if (myData.role === 'jailer') {
            const isExecuting = targetId.startsWith('execute_');
            const actualTargetId = isExecuting ? targetId.substring(8) : targetId;
            updates.jailedPlayerId = actualTargetId;
            updates.jailerId = currentUser.uid;
            showToast(isExecuting ? 'Execution scheduled.' : 'Player jailed.');
        }

        if (myData.role === 'seer') {
            const targetPlayer = localGameState.players[targetId];
            const isWolfTeam = (targetPlayer.role === 'werewolf' && !targetPlayer.isAlpha);
            
            document.getElementById('seer-result-body').textContent = `${getDisplayName(targetPlayer)} is ${isWolfTeam ? 'a Werewolf' : 'not a Werewolf'}.`;
            showModal('seer-result-modal', true);
            showToast('Vision received.');
            updates[`players.${currentUser.uid}.hasUsedAbilityThisTurn`] = true;

            const mimic = Object.entries(localGameState.players).find(([id, p]) => p.role === 'mimic');
            if (mimic) {
                const mimicId = mimic[0];
                updates[`players.${mimicId}.privateMessage`] = `Mimic Vision: ${getDisplayName(targetPlayer)} is ${isWolfTeam ? 'a Werewolf' : 'not a Werewolf'}.`;
            }

        } else if (myData.role !== 'jailer') {
            showToast('Action registered.');
        }
        await updateDoc(roomRef, updates);
    }

    async function selectRoleModel(targetId) {
        const roomRef = doc(db, 'rooms', currentRoomId);
        showToast(`You have chosen ${getDisplayName(localGameState.players[targetId])} as your role model.`);
        await updateDoc(roomRef, { [`players.${currentUser.uid}.roleModel`]: targetId });
    }

    async function performDevAction(targetId, actionType) {
        const roomRef = doc(db, 'rooms', currentRoomId);
        showToast(`Dev Action: ${actionType} on ${getDisplayName(localGameState.players[targetId])}`, true);
        
        const currentDevActions = localGameState.devActions || {};

        if (actionType === 'kill') {
            const isTargeted = (currentDevActions.kill || []).includes(targetId);
            return await updateDoc(roomRef, { 
                [`devActions.kill`]: isTargeted ? arrayRemove(targetId) : arrayUnion(targetId) 
            });
        }
        if (actionType === 'protect') {
            const isProtected = currentDevActions.protect === targetId;
            return await updateDoc(roomRef, { [`devActions.protect`]: isProtected ? null : targetId });
        }
        if (actionType === 'revive') {
            return await updateDoc(roomRef, { 
                [`players.${targetId}.isAlive`]: true,
                [`players.${targetId}.actionTarget`]: deleteField(),
                [`players.${targetId}.votedFor`]: deleteField()
            });
        }
        if (actionType === 'seer') {
            const targetPlayer = localGameState.players[targetId];
            document.getElementById('seer-result-body').textContent = `${getDisplayName(targetPlayer)} is a ${targetPlayer.role}.`;
            return showModal('seer-result-modal', true);
        }
    }

    async function voteForPlayer(targetId) {
        const myData = localGameState.players[currentUser.uid];
        const roomRef = doc(db, 'rooms', currentRoomId);
        const updates = {};

        if (targetId === '__SKIP__') {
            if (myData.votedFor === '__SKIP__') { 
                showToast('Vote cancelled.');
                updates[`players.${currentUser.uid}.votedFor`] = deleteField();
            } else { 
                showToast('Vote skipped.');
                updates[`players.${currentUser.uid}.votedFor`] = '__SKIP__';
            }
        } else if (myData.votedFor === targetId) {
            showToast('Vote cancelled.');
            updates[`players.${currentUser.uid}.votedFor`] = deleteField();
        } else {
            showToast('Vote cast.');
            updates[`players.${currentUser.uid}.votedFor`] = targetId;
        }

        if (myData.role === 'mayor' && myData.isMayorRevealed) {
            updates.mayorVoteCast = true;
        }
        
        await updateDoc(roomRef, updates);
    }
    
    async function sendMessage(isJailChat = false) {
        const inputId = isJailChat ? 'jail-chat-input' : 'chat-input';
        const input = document.getElementById(inputId);
        const text = input.value.trim();
        if (!text) return;

        if (isJailChat) {
            const roomRef = doc(db, 'rooms', currentRoomId);
            await updateDoc(roomRef, {
                jailChatMessages: arrayUnion({
                    uid: currentUser.uid,
                    nickname: currentUser.displayName,
                    text: text,
                    timestamp: Timestamp.now()
                })
            });
        } else {
            const chatRef = collection(db, 'rooms', currentRoomId, 'messages');
            await addDoc(chatRef, {
                uid: currentUser.uid, nickname: currentUser.displayName,
                isDeveloper: currentUser.isDeveloper, text: text, timestamp: serverTimestamp()
            });
        }
        input.value = '';
    }

    function renderJailChat(roomData) {
        const { jailerId, jailedPlayerId, jailChatMessages = [] } = roomData;
        const messagesDiv = document.getElementById('jail-chat-messages');
        const titleEl = document.getElementById('jail-chat-title');
        
        const otherPlayerId = currentUser.uid === jailerId ? jailedPlayerId : jailerId;
        const otherPlayerName = getDisplayName(roomData.players[otherPlayerId]);
        titleEl.textContent = `Interrogating ${otherPlayerName}`;
        
        messagesDiv.innerHTML = '';
        jailChatMessages.forEach(msg => {
            const msgEl = document.createElement('div');
            const displayName = getDisplayName(msg);
            msgEl.innerHTML = `<p class="mb-1"><strong>${displayName}</strong>: ${msg.text}</p>`;
            messagesDiv.appendChild(msgEl);
        });
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }
    
    function updateTimer(endTime, state, mayorVoteCast = false) {
        if (gameTimerInterval) clearInterval(gameTimerInterval);
        const timerEl = document.getElementById('game-timer');
        const timerSubtitleEl = document.getElementById('timer-subtitle');
        if (!endTime || !endTime.seconds) { timerEl.textContent = '--:--'; return; }
        
        timerSubtitleEl.textContent = 'TIME REMAINING';
        document.body.classList.remove('timer-low-tension');

        if (state === 'day' && mayorVoteCast) {
            timerEl.textContent = '00:00';
            timerSubtitleEl.textContent = 'PROCESSING...';
            return;
        }

        const update = () => {
            const remaining = Math.max(0, Math.round((endTime.seconds * 1000 - Date.now()) / 1000));
            timerEl.textContent = `${String(Math.floor(remaining / 60)).padStart(2, '0')}:${String(remaining % 60).padStart(2, '0')}`;
            
            if (remaining <= 10 && remaining > 0) {
                timerEl.classList.add('text-red-500');
                timerEl.style.animation = 'pulse 1s infinite';
                document.body.classList.add('timer-low-tension');
            } else {
                timerEl.classList.remove('text-red-500');
                timerEl.style.animation = '';
                document.body.classList.remove('timer-low-tension');
            }
            
            if (remaining <= 0) {
                clearInterval(gameTimerInterval);
                timerEl.textContent = '00:00';
                timerSubtitleEl.textContent = 'PROCESSING...';
                isProcessingPhase = true;
                renderPlayerCards(localGameState);
            }
        };

        update();
        gameTimerInterval = setInterval(update, 1000);
    }

    function queueModal(modalConfig) {
        modalQueue.push(modalConfig);
        processModalQueue();
    }

    function processModalQueue() {
        if (isModalActive || modalQueue.length === 0) {
            return;
        }
        isModalActive = true;
        const config = modalQueue.shift();

        if (config.type === 'phase') {
            playPhaseTransition(config.phase, config.turn);
        } else if (config.type === 'event') {
            showModal('event-modal', true);
            if (config.onShow) config.onShow();
        }
    }

    function playPhaseTransition(phase, turn) {
        const overlay = document.getElementById('phase-transition-overlay');
        const icon = document.getElementById('phase-icon');
        const title = document.getElementById('phase-title');
        
        if (phase === 'day') {
            overlay.className = 'day';
            icon.textContent = '‚òÄÔ∏è';
            title.textContent = `Day ${turn}`;
        } else {
            overlay.className = 'night';
            icon.textContent = 'üåô';
            title.textContent = `Night ${turn}`;
        }
        overlay.classList.add('visible');
        setTimeout(() => {
            overlay.classList.remove('visible');
            isModalActive = false;
            processModalQueue();
        }, 2000);
    }

    function applyTheme(theme) {
        if (theme === 'light') {
            document.body.classList.add('light-theme');
        } else {
            document.body.classList.remove('light-theme');
        }
    }

    window.performNightAction = performNightAction;
    window.performDevAction = performDevAction;
    window.voteForPlayer = voteForPlayer;
    window.selectRoleModel = selectRoleModel;

    document.getElementById('btn-create-room').addEventListener('click', createRoom);
    document.getElementById('btn-join').addEventListener('click', ()=>{
      const code = document.getElementById('join-code').value.trim().toUpperCase();
      if(code) joinRoom(code); else showToast('Enter a room code', true);
    });
    document.getElementById('btn-leave').addEventListener('click', leaveRoom);
    document.querySelectorAll('.setting-input').forEach(input => input.addEventListener('change', updateSettingsInDb));
    document.getElementById('btn-start').addEventListener('click', startGame);
    document.getElementById('chat-send').addEventListener('click', () => sendMessage(false));
    document.getElementById('chat-input').addEventListener('keypress', (e) => { if (e.key === 'Enter') sendMessage(false); });
    document.getElementById('jail-chat-send').addEventListener('click', () => sendMessage(true));
    document.getElementById('jail-chat-input').addEventListener('keypress', (e) => { if (e.key === 'Enter') sendMessage(true); });
    document.getElementById('skip-vote-btn').addEventListener('click', () => voteForPlayer('__SKIP__'));
    document.getElementById('ignite-btn').addEventListener('click', () => performNightAction('__IGNITE__'));
    document.getElementById('reveal-mayor-btn').addEventListener('click', async () => {
        const roomRef = doc(db, 'rooms', currentRoomId);
        await updateDoc(roomRef, { [`players.${currentUser.uid}.isMayorRevealed`]: true });
        showToast('You have revealed yourself as the Mayor!');
    });
    document.getElementById('jailer-interrogate-btn').addEventListener('click', () => showModal('jail-chat-modal', true));
    document.getElementById('jailer-execute-btn').addEventListener('click', () => {
        if (confirm("Are you sure you want to execute this player? This action is final.")) {
            performNightAction(`execute_${localGameState.jailedPlayerId}`);
        }
    });
    document.getElementById('dev-end-game').addEventListener('click', async () => {
        if (confirm("End game? This will reveal all roles.")) {
            const roomRef = doc(db, 'rooms', currentRoomId);
            const roomData = (await getDoc(roomRef)).data();
            await updateDoc(roomRef, { 
                state: 'game_over',
                gameOver: { winningTeam: "Nobody", reason: "Game ended by a Developer.", players: roomData.players }
            });
        }
    });

    document.getElementById('theme-toggle-btn').addEventListener('click', () => {
        const isLight = document.body.classList.contains('light-theme');
        const newTheme = isLight ? 'dark' : 'light';
        localStorage.setItem('whoswolf-theme', newTheme);
        applyTheme(newTheme);
    });

    document.getElementById('btn-how-to-play').addEventListener('click', () => showModal('rules-modal-backdrop', true));
    document.getElementById('btn-close-rules').addEventListener('click', () => showModal('rules-modal-backdrop', false));

    (function init(){
      const savedTheme = localStorage.getItem('whoswolf-theme') || 'dark';
      applyTheme(savedTheme);
      setLoading(true);
      initializeFirebase();
      const roomCode = new URLSearchParams(location.search).get('room');
      if (roomCode) document.getElementById('join-code').value = roomCode.toUpperCase();
    })();
  </script>
</body>
</html>